diff --bs samba.2370/patches.tar.bz2/samba.org/0e398b83e6ec20266258d25b0960e09f1a8ef5f2 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/0e398b83e6ec20266258d25b0960e09f1a8ef5f2
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/0e398b83e6ec20266258d25b0960e09f1a8ef5f2
@@ -0,0 +1,41 @@
+From 0e398b83e6ec20266258d25b0960e09f1a8ef5f2 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 25 Apr 2016 16:12:47 +0200
+Subject: [PATCH] s3:selftest: add smbclient_ntlm tests
+
+We test all combinations of NT1 with and without spnego and SMB3
+for user, anonymous and guest authentication.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/selftest/tests.py | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git source3/selftest/tests.py source3/selftest/tests.py
+index 5d7346d..a2190bc 100755
+--- source3/selftest/tests.py
++++ source3/selftest/tests.py
+@@ -128,8 +128,9 @@ for options in ["--option=clientusespnego=no", " --option=clientntlmv2auth=no --
+     env = "s3dc"
+     plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) %s" % (env, options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
+ 
+-for env in ["s3dc", "member", "s3member", "dc", "s4member"]:
++for env in ["s3dc", "member", "s3member", "dc", "s4member","fl2000dc"]:
+     plantestsuite("samba3.blackbox.smbclient_machine_auth.plain (%s:local)" % env, "%s:local" % env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_machine_auth.sh"), '$SERVER', smbclient3, configuration])
++    plantestsuite("samba3.blackbox.smbclient_ntlm.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$DC_USERNAME', '$DC_PASSWORD', "never", smbclient3, configuration])
+ 
+ for env in ["s3dc", "member", "s3member"]:
+     plantestsuite("samba3.blackbox.smbclient_auth.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration])
+@@ -155,6 +156,7 @@ for env in ["maptoguest", "simpleserver"]:
+ 
+ env = "maptoguest"
+ plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) bad username" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', 'notmy$USERNAME', '$PASSWORD', smbclient3, configuration + " --option=clientntlmv2auth=no --option=clientlanmanauth=yes"])
++plantestsuite("samba3.blackbox.smbclient_ntlm.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$USERNAME', '$PASSWORD', "baduser", smbclient3, configuration])
+ 
+ # plain
+ for env in ["s3dc"]:
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/116b9aedc9cb4a0671a720e4e1ea14d57235c56b samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/116b9aedc9cb4a0671a720e4e1ea14d57235c56b
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/116b9aedc9cb4a0671a720e4e1ea14d57235c56b
@@ -0,0 +1,59 @@
+From 116b9aedc9cb4a0671a720e4e1ea14d57235c56b Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Tue, 19 Apr 2016 07:19:19 +0200
+Subject: [PATCH 12/27] s3:libsmb: record the session setup action flags
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/libsmb/cliconnect.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git source3/libsmb/cliconnect.c source3/libsmb/cliconnect.c
+index b8a8c7a..48f499c 100644
+--- source3/libsmb/cliconnect.c
++++ source3/libsmb/cliconnect.c
+@@ -242,6 +242,7 @@ static void cli_session_setup_lanman2_done(struct tevent_req *subreq)
+ 	p = bytes;
+ 
+ 	cli_state_set_uid(state-&gt;cli, SVAL(inhdr, HDR_UID));
++	smb1cli_session_set_action(cli-&gt;smb1.session, SVAL(vwv+2, 0));
+ 
+ 	status = smb_bytes_talloc_string(cli,
+ 					inhdr,
+@@ -449,6 +450,7 @@ static void cli_session_setup_guest_done(struct tevent_req *subreq)
+ 	p = bytes;
+ 
+ 	cli_state_set_uid(state-&gt;cli, SVAL(inhdr, HDR_UID));
++	smb1cli_session_set_action(cli-&gt;smb1.session, SVAL(vwv+2, 0));
+ 
+ 	status = smb_bytes_talloc_string(cli,
+ 					inhdr,
+@@ -613,6 +615,7 @@ static void cli_session_setup_plain_done(struct tevent_req *subreq)
+ 	p = bytes;
+ 
+ 	cli_state_set_uid(state-&gt;cli, SVAL(inhdr, HDR_UID));
++	smb1cli_session_set_action(cli-&gt;smb1.session, SVAL(vwv+2, 0));
+ 
+ 	status = smb_bytes_talloc_string(cli,
+ 					inhdr,
+@@ -929,6 +932,7 @@ static void cli_session_setup_nt1_done(struct tevent_req *subreq)
+ 	p = bytes;
+ 
+ 	cli_state_set_uid(state-&gt;cli, SVAL(inhdr, HDR_UID));
++	smb1cli_session_set_action(cli-&gt;smb1.session, SVAL(vwv+2, 0));
+ 
+ 	status = smb_bytes_talloc_string(cli,
+ 					inhdr,
+@@ -1178,6 +1182,7 @@ static void cli_sesssetup_blob_done(struct tevent_req *subreq)
+ 	state-&gt;inbuf = in;
+ 	inhdr = in + NBT_HDR_SIZE;
+ 	cli_state_set_uid(state-&gt;cli, SVAL(inhdr, HDR_UID));
++	smb1cli_session_set_action(cli-&gt;smb1.session, SVAL(vwv+2, 0));
+ 
+ 	blob_length = SVAL(vwv+3, 0);
+ 	if (blob_length &gt; num_bytes) {
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/285b7e3a1e3c3673a8b7439a1c96c5b44178078e samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/285b7e3a1e3c3673a8b7439a1c96c5b44178078e
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/285b7e3a1e3c3673a8b7439a1c96c5b44178078e
@@ -0,0 +1,33 @@
+From 285b7e3a1e3c3673a8b7439a1c96c5b44178078e Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Fri, 22 Apr 2016 16:18:24 +0200
+Subject: [PATCH 02/27] s4:gensec_tstream: allow wrapped messages up to a size
+ of 0xfffffff
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11872
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source4/auth/gensec/gensec_tstream.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+diff --git source4/auth/gensec/gensec_tstream.c source4/auth/gensec/gensec_tstream.c
+index 92f4fa6..c828170 100644
+--- source4/auth/gensec/gensec_tstream.c
++++ source4/auth/gensec/gensec_tstream.c
+@@ -253,7 +253,11 @@ static int tstream_gensec_readv_next_vector(struct tstream_context *unix_stream,
+ 
+ 		msg_len = RIVAL(state-&gt;wrapped.hdr, 0);
+ 
+-		if (msg_len &gt; 0x00FFFFFF) {
++		/*
++		 * I got a Windows 2012R2 server responding with
++		 * a message of 0x1b28a33.
++		 */
++		if (msg_len &gt; 0x0FFFFFFF) {
+ 			errno = EMSGSIZE;
+ 			return -1;
+ 		}
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/2bc6a9c82fbb54793e121be862c7f617bfc3c063 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/2bc6a9c82fbb54793e121be862c7f617bfc3c063
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/2bc6a9c82fbb54793e121be862c7f617bfc3c063
@@ -0,0 +1,82 @@
+From 2bc6a9c82fbb54793e121be862c7f617bfc3c063 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Fri, 22 Apr 2016 10:04:38 +0200
+Subject: [PATCH 15/27] auth/spnego: only try to verify the mechListMic if
+ signing was negotiated.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/gensec/spnego.c | 18 ++++++++++--------
+ 1 file changed, 10 insertions(+), 8 deletions(-)
+
+diff --git auth/gensec/spnego.c auth/gensec/spnego.c
+index f82d5bb..1323bfe 100644
+--- auth/gensec/spnego.c
++++ auth/gensec/spnego.c
+@@ -885,6 +885,7 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 	case SPNEGO_SERVER_TARG:
+ 	{
+ 		NTSTATUS nt_status;
++		bool have_sign = true;
+ 		bool new_spnego = false;
+ 
+ 		if (!in.length) {
+@@ -947,18 +948,20 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 			goto server_response;
+ 		}
+ 
++		have_sign = gensec_have_feature(spnego_state-&gt;sub_sec_security,
++						GENSEC_FEATURE_SIGN);
+ 		new_spnego = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+ 						 GENSEC_FEATURE_NEW_SPNEGO);
+ 		if (spnego.negTokenTarg.mechListMIC.length &gt; 0) {
+ 			new_spnego = true;
+ 		}
+ 
+-		if (new_spnego) {
++		if (have_sign &amp;&amp; new_spnego) {
+ 			spnego_state-&gt;needs_mic_check = true;
+ 			spnego_state-&gt;needs_mic_sign = true;
+ 		}
+ 
+-		if (spnego.negTokenTarg.mechListMIC.length &gt; 0) {
++		if (have_sign &amp;&amp; spnego.negTokenTarg.mechListMIC.length &gt; 0) {
+ 			nt_status = gensec_check_packet(spnego_state-&gt;sub_sec_security,
+ 							spnego_state-&gt;mech_types.data,
+ 							spnego_state-&gt;mech_types.length,
+@@ -1142,8 +1145,11 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 		if (spnego_state-&gt;no_response_expected &amp;&amp;
+ 		    !spnego_state-&gt;done_mic_check)
+ 		{
++			bool have_sign = true;
+ 			bool new_spnego = false;
+ 
++			have_sign = gensec_have_feature(spnego_state-&gt;sub_sec_security,
++							GENSEC_FEATURE_SIGN);
+ 			new_spnego = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+ 							 GENSEC_FEATURE_NEW_SPNEGO);
+ 
+@@ -1170,16 +1176,12 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 			}
+ 
+ 			if (spnego_state-&gt;mic_requested) {
+-				bool sign;
+-
+-				sign = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+-							   GENSEC_FEATURE_SIGN);
+-				if (sign) {
++				if (have_sign) {
+ 					new_spnego = true;
+ 				}
+ 			}
+ 
+-			if (new_spnego) {
++			if (have_sign &amp;&amp; new_spnego) {
+ 				spnego_state-&gt;needs_mic_check = true;
+ 				spnego_state-&gt;needs_mic_sign = true;
+ 			}
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/2d69bcfa3a19d72ceecfd10f9632aea807424a3f samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/2d69bcfa3a19d72ceecfd10f9632aea807424a3f
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/2d69bcfa3a19d72ceecfd10f9632aea807424a3f
@@ -0,0 +1,32 @@
+From 2d69bcfa3a19d72ceecfd10f9632aea807424a3f Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 18 Apr 2016 17:34:21 +0200
+Subject: [PATCH 10/27] libcli/smb: add SMB1 session setup action flags
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ libcli/smb/smb_constants.h | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git libcli/smb/smb_constants.h libcli/smb/smb_constants.h
+index 57915d9..e03e843 100644
+--- libcli/smb/smb_constants.h
++++ libcli/smb/smb_constants.h
+@@ -276,6 +276,12 @@ enum smb_signing_setting {
+ 	CAP_LARGE_WRITEX | \
+ 	0)
+ 
++/*
++ * The action flags in the SMB session setup response
++ */
++#define SMB_SETUP_GUEST          0x0001
++#define SMB_SETUP_USE_LANMAN_KEY 0x0002
++
+ /* Client-side offline caching policy types */
+ enum csc_policy {
+ 	CSC_POLICY_MANUAL=0,
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/3d3298731201cb38eddb4f43173d3592998f6a81 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/3d3298731201cb38eddb4f43173d3592998f6a81
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/3d3298731201cb38eddb4f43173d3592998f6a81
@@ -0,0 +1,55 @@
+From 3d3298731201cb38eddb4f43173d3592998f6a81 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 18 Apr 2016 17:33:11 +0200
+Subject: [PATCH 09/27] libcli/smb: add smb1cli_session_set_action() helper
+ function
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ libcli/smb/smbXcli_base.c | 7 +++++++
+ libcli/smb/smbXcli_base.h | 2 ++
+ 2 files changed, 9 insertions(+)
+
+diff --git libcli/smb/smbXcli_base.c libcli/smb/smbXcli_base.c
+index e502dc8..d8b85c8 100644
+--- libcli/smb/smbXcli_base.c
++++ libcli/smb/smbXcli_base.c
+@@ -152,6 +152,7 @@ struct smbXcli_session {
+ 
+ 	struct {
+ 		uint16_t session_id;
++		uint16_t action;
+ 		DATA_BLOB application_key;
+ 		bool protected_key;
+ 	} smb1;
+@@ -5016,6 +5017,12 @@ void smb1cli_session_set_id(struct smbXcli_session *session,
+ 	session-&gt;smb1.session_id = session_id;
+ }
+ 
++void smb1cli_session_set_action(struct smbXcli_session *session,
++				uint16_t action)
++{
++	session-&gt;smb1.action = action;
++}
++
+ NTSTATUS smb1cli_session_set_session_key(struct smbXcli_session *session,
+ 					 const DATA_BLOB _session_key)
+ {
+diff --git libcli/smb/smbXcli_base.h libcli/smb/smbXcli_base.h
+index ffccd7e..8eb482a 100644
+--- libcli/smb/smbXcli_base.h
++++ libcli/smb/smbXcli_base.h
+@@ -379,6 +379,8 @@ void smbXcli_session_set_disconnect_expired(struct smbXcli_session *session);
+ uint16_t smb1cli_session_current_id(struct smbXcli_session* session);
+ void smb1cli_session_set_id(struct smbXcli_session* session,
+ 			    uint16_t session_id);
++void smb1cli_session_set_action(struct smbXcli_session *session,
++				uint16_t action);
+ NTSTATUS smb1cli_session_set_session_key(struct smbXcli_session *session,
+ 					 const DATA_BLOB _session_key);
+ NTSTATUS smb1cli_session_protect_session_key(struct smbXcli_session *session);
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/40484b3ae634e3ec7ac35ed0b362210f8f577faf samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/40484b3ae634e3ec7ac35ed0b362210f8f577faf
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/40484b3ae634e3ec7ac35ed0b362210f8f577faf
@@ -0,0 +1,76 @@
+From 40484b3ae634e3ec7ac35ed0b362210f8f577faf Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 20 Apr 2016 16:29:42 +0200
+Subject: [PATCH 18/27] libcli/security: implement SECURITY_GUEST
+
+SECURITY_GUEST is not exactly the same as SECURITY_ANONYMOUS.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ libcli/security/security_token.c | 5 +++++
+ libcli/security/security_token.h | 2 ++
+ libcli/security/session.c        | 4 ++++
+ libcli/security/session.h        | 1 +
+ 4 files changed, 12 insertions(+)
+
+diff --git libcli/security/security_token.c libcli/security/security_token.c
+index 6812d42..2e5a87b 100644
+--- libcli/security/security_token.c
++++ libcli/security/security_token.c
+@@ -130,6 +130,11 @@ bool security_token_has_sid_string(const struct security_token *token, const cha
+ 	return ret;
+ }
+ 
++bool security_token_has_builtin_guests(const struct security_token *token)
++{
++	return security_token_has_sid(token, &amp;global_sid_Builtin_Guests);
++}
++
+ bool security_token_has_builtin_administrators(const struct security_token *token)
+ {
+ 	return security_token_has_sid(token, &amp;global_sid_Builtin_Administrators);
+diff --git libcli/security/security_token.h libcli/security/security_token.h
+index b8ca990..5c5b30b 100644
+--- libcli/security/security_token.h
++++ libcli/security/security_token.h
+@@ -51,6 +51,8 @@ bool security_token_has_sid(const struct security_token *token, const struct dom
+ 
+ bool security_token_has_sid_string(const struct security_token *token, const char *sid_string);
+ 
++bool security_token_has_builtin_guests(const struct security_token *token);
++
+ bool security_token_has_builtin_administrators(const struct security_token *token);
+ 
+ bool security_token_has_nt_authenticated_users(const struct security_token *token);
+diff --git libcli/security/session.c libcli/security/session.c
+index 0c32556..0fbb87d 100644
+--- libcli/security/session.c
++++ libcli/security/session.c
+@@ -38,6 +38,10 @@ enum security_user_level security_session_user_level(struct auth_session_info *s
+ 		return SECURITY_ANONYMOUS;
+ 	}
+ 
++	if (security_token_has_builtin_guests(session_info-&gt;security_token)) {
++		return SECURITY_GUEST;
++	}
++
+ 	if (security_token_has_builtin_administrators(session_info-&gt;security_token)) {
+ 		return SECURITY_ADMINISTRATOR;
+ 	}
+diff --git libcli/security/session.h libcli/security/session.h
+index ee9187d..31e950e 100644
+--- libcli/security/session.h
++++ libcli/security/session.h
+@@ -24,6 +24,7 @@
+ 
+ enum security_user_level {
+ 	SECURITY_ANONYMOUS            = 0,
++	SECURITY_GUEST                = 1,
+ 	SECURITY_USER                 = 10,
+ 	SECURITY_RO_DOMAIN_CONTROLLER = 20,
+ 	SECURITY_DOMAIN_CONTROLLER    = 30,
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/40ceb541057dbbfea497948c624b7a70c8540135 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/40ceb541057dbbfea497948c624b7a70c8540135
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/40ceb541057dbbfea497948c624b7a70c8540135
@@ -0,0 +1,35 @@
+From 40ceb541057dbbfea497948c624b7a70c8540135 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 20 Apr 2016 18:44:21 +0200
+Subject: [PATCH 06/27] auth/ntlmssp: don't require NTLMSSP_SIGN for smb
+ connections
+
+Enforcement of SMB signing is done at the SMB layer.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11850
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/ntlmssp/ntlmssp_client.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git auth/ntlmssp/ntlmssp_client.c auth/ntlmssp/ntlmssp_client.c
+index 8b367fc..b423f20 100644
+--- auth/ntlmssp/ntlmssp_client.c
++++ auth/ntlmssp/ntlmssp_client.c
+@@ -843,8 +843,11 @@ NTSTATUS gensec_ntlmssp_client_start(struct gensec_security *gensec_security)
+ 		 * Without this, Windows will not create the master key
+ 		 * that it thinks is only used for NTLMSSP signing and
+ 		 * sealing.  (It is actually pulled out and used directly)
++		 *
++		 * We don't require this here as some servers (e.g. NetAPP)
++		 * doesn't support this.
+ 		 */
+-		ntlmssp_state-&gt;required_flags |= NTLMSSP_NEGOTIATE_SIGN;
++		ntlmssp_state-&gt;neg_flags |= NTLMSSP_NEGOTIATE_SIGN;
+ 	}
+ 	if (gensec_security-&gt;want_features &amp; GENSEC_FEATURE_SIGN) {
+ 		ntlmssp_state-&gt;required_flags |= NTLMSSP_NEGOTIATE_SIGN;
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/4a03836b3d6e5bb8b233c35aae916033acf21d7e samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/4a03836b3d6e5bb8b233c35aae916033acf21d7e
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/4a03836b3d6e5bb8b233c35aae916033acf21d7e
@@ -0,0 +1,93 @@
+From 4a03836b3d6e5bb8b233c35aae916033acf21d7e Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 25 Apr 2016 14:45:55 +0200
+Subject: [PATCH 22/27] auth/spnego: add spnego:simulate_w2k option for testing
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/gensec/spnego.c | 28 +++++++++++++++++++++++++++-
+ 1 file changed, 27 insertions(+), 1 deletion(-)
+
+diff --git auth/gensec/spnego.c auth/gensec/spnego.c
+index 1323bfe..0b49b1a 100644
+--- auth/gensec/spnego.c
++++ auth/gensec/spnego.c
+@@ -59,6 +59,8 @@ struct spnego_state {
+ 	bool needs_mic_check;
+ 	bool done_mic_check;
+ 
++	bool simulate_w2k;
++
+ 	/*
+ 	 * The following is used to implement
+ 	 * the update token fragmentation
+@@ -88,6 +90,9 @@ static NTSTATUS gensec_spnego_client_start(struct gensec_security *gensec_securi
+ 	spnego_state-&gt;out_max_length = gensec_max_update_size(gensec_security);
+ 	spnego_state-&gt;out_status = NT_STATUS_MORE_PROCESSING_REQUIRED;
+ 
++	spnego_state-&gt;simulate_w2k = gensec_setting_bool(gensec_security-&gt;settings,
++						"spnego", "simulate_w2k", false);
++
+ 	gensec_security-&gt;private_data = spnego_state;
+ 	return NT_STATUS_OK;
+ }
+@@ -109,6 +114,9 @@ static NTSTATUS gensec_spnego_server_start(struct gensec_security *gensec_securi
+ 	spnego_state-&gt;out_max_length = gensec_max_update_size(gensec_security);
+ 	spnego_state-&gt;out_status = NT_STATUS_MORE_PROCESSING_REQUIRED;
+ 
++	spnego_state-&gt;simulate_w2k = gensec_setting_bool(gensec_security-&gt;settings,
++						"spnego", "simulate_w2k", false);
++
+ 	gensec_security-&gt;private_data = spnego_state;
+ 	return NT_STATUS_OK;
+ }
+@@ -775,11 +783,23 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 								     spnego.negTokenInit.mechToken, 
+ 								     &amp;unwrapped_out);
+ 
++			if (spnego_state-&gt;simulate_w2k) {
++				/*
++				 * Windows 2000 returns the unwrapped token
++				 * also in the mech_list_mic field.
++				 *
++				 * In order to verify our client code,
++				 * we need a way to have a server with this
++				 * broken behaviour
++				 */
++				mech_list_mic = unwrapped_out;
++			}
++
+ 			nt_status = gensec_spnego_server_negTokenTarg(spnego_state,
+ 								      out_mem_ctx,
+ 								      nt_status,
+ 								      unwrapped_out,
+-								      null_data_blob,
++								      mech_list_mic,
+ 								      out);
+ 
+ 			spnego_free_data(&amp;spnego);
+@@ -950,6 +970,9 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 
+ 		have_sign = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+ 						GENSEC_FEATURE_SIGN);
++		if (spnego_state-&gt;simulate_w2k) {
++			have_sign = false;
++		}
+ 		new_spnego = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+ 						 GENSEC_FEATURE_NEW_SPNEGO);
+ 		if (spnego.negTokenTarg.mechListMIC.length &gt; 0) {
+@@ -1150,6 +1173,9 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 
+ 			have_sign = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+ 							GENSEC_FEATURE_SIGN);
++			if (spnego_state-&gt;simulate_w2k) {
++				have_sign = false;
++			}
+ 			new_spnego = gensec_have_feature(spnego_state-&gt;sub_sec_security,
+ 							 GENSEC_FEATURE_NEW_SPNEGO);
+ 
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/4dc5f1504f790df5b54fe62cbe5e80481966f0fd samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/4dc5f1504f790df5b54fe62cbe5e80481966f0fd
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/4dc5f1504f790df5b54fe62cbe5e80481966f0fd
@@ -0,0 +1,29 @@
+From 4dc5f1504f790df5b54fe62cbe5e80481966f0fd Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Tue, 26 Apr 2016 11:33:52 +0200
+Subject: [PATCH 25/27] s3:test_smbclient_auth.sh: this script reqiures 5
+ arguments
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/script/tests/test_smbclient_auth.sh | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git source3/script/tests/test_smbclient_auth.sh source3/script/tests/test_smbclient_auth.sh
+index cc075b9..1681772 100755
+--- source3/script/tests/test_smbclient_auth.sh
++++ source3/script/tests/test_smbclient_auth.sh
+@@ -2,7 +2,7 @@
+ 
+ # this runs the file serving tests that are expected to pass with samba3 against shares with various options
+ 
+-if [ $# -lt 4 ]; then
++if [ $# -lt 5 ]; then
+ cat &lt;&lt;EOF
+ Usage: test_smbclient_auth.sh SERVER SERVER_IP USERNAME PASSWORD SMBCLIENT &lt;smbclient arguments&gt;
+ EOF
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/4fdc21e37451504d0d5cbb3a3d02e4bfcc728907 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/4fdc21e37451504d0d5cbb3a3d02e4bfcc728907
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/4fdc21e37451504d0d5cbb3a3d02e4bfcc728907
@@ -0,0 +1,40 @@
+From 8fb8724f2c4220bcde344d79193fb7c4e5825e7d Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 25 Apr 2016 16:02:22 +0200
+Subject: [PATCH] selftest:Samba4: let fl2000dc use Windows2000 style
+ SPNEGO/NTLMSSP
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ selftest/target/Samba4.pm | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+diff --git selftest/target/Samba4.pm selftest/target/Samba4.pm
+index ef3b45d..c97d16b 100755
+--- selftest/target/Samba4.pm
++++ selftest/target/Samba4.pm
+@@ -1144,6 +1144,10 @@ sub provision_fl2000dc($$)
+ 	my ($self, $prefix) = @_;
+ 
+ 	print "PROVISIONING DC...";
++	my $extra_conf_options = "
++	spnego:simulate_w2k=yes
++	ntlmssp_server:force_old_spnego=yes
++";
+ 	my $ret = $self-&gt;provision($prefix,
+ 				   "domain controller",
+ 				   "dc5",
+@@ -1151,7 +1155,7 @@ sub provision_fl2000dc($$)
+ 				   "samba2000.example.com",
+ 				   "2000",
+ 				   "locDCpass5",
+-				   undef, "", "", undef);
++				   undef, $extra_conf_options, "", undef);
+ 
+ 	unless($self-&gt;add_wins_config("$prefix/private")) {
+ 		warn("Unable to add wins configuration");
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/5013b9ce4f87b4ebd806fbaf7660bceaa219fc4c samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/5013b9ce4f87b4ebd806fbaf7660bceaa219fc4c
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/5013b9ce4f87b4ebd806fbaf7660bceaa219fc4c
@@ -0,0 +1,78 @@
+From 5013b9ce4f87b4ebd806fbaf7660bceaa219fc4c Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 27 Apr 2016 01:48:32 +0200
+Subject: [PATCH 17/27] s3:auth_builtin: anonymous authentication doesn't allow
+ a password
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/auth/auth_builtin.c | 47 ++++++++++++++++++++++++++++++++++++++-------
+ 1 file changed, 40 insertions(+), 7 deletions(-)
+
+diff --git source3/auth/auth_builtin.c source3/auth/auth_builtin.c
+index dce58bf..7480799 100644
+--- source3/auth/auth_builtin.c
++++ source3/auth/auth_builtin.c
+@@ -38,17 +38,50 @@ static NTSTATUS check_guest_security(const struct auth_context *auth_context,
+ 				     const struct auth_usersupplied_info *user_info,
+ 				     struct auth_serversupplied_info **server_info)
+ {
+-	/* mark this as 'not for me' */
+-	NTSTATUS nt_status = NT_STATUS_NOT_IMPLEMENTED;
+-
+ 	DEBUG(10, ("Check auth for: [%s]\n", user_info-&gt;mapped.account_name));
+ 
+-	if (!(user_info-&gt;mapped.account_name
+-	      &amp;&amp; *user_info-&gt;mapped.account_name)) {
+-		nt_status = make_server_info_guest(NULL, server_info);
++	if (user_info-&gt;mapped.account_name &amp;&amp; *user_info-&gt;mapped.account_name) {
++		/* mark this as 'not for me' */
++		return NT_STATUS_NOT_IMPLEMENTED;
+ 	}
+ 
+-	return nt_status;
++	switch (user_info-&gt;password_state) {
++	case AUTH_PASSWORD_PLAIN:
++		if (user_info-&gt;password.plaintext != NULL &amp;&amp;
++		    strlen(user_info-&gt;password.plaintext) &gt; 0)
++		{
++			/* mark this as 'not for me' */
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		break;
++	case AUTH_PASSWORD_HASH:
++		if (user_info-&gt;password.hash.lanman != NULL) {
++			/* mark this as 'not for me' */
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		if (user_info-&gt;password.hash.nt != NULL) {
++			/* mark this as 'not for me' */
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		break;
++	case AUTH_PASSWORD_RESPONSE:
++		if (user_info-&gt;password.response.lanman.length == 1) {
++			if (user_info-&gt;password.response.lanman.data[0] != '\0') {
++				/* mark this as 'not for me' */
++				return NT_STATUS_NOT_IMPLEMENTED;
++			}
++		} else if (user_info-&gt;password.response.lanman.length &gt; 1) {
++			/* mark this as 'not for me' */
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		if (user_info-&gt;password.response.nt.length &gt; 0) {
++			/* mark this as 'not for me' */
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		break;
++	}
++
++	return make_server_info_guest(NULL, server_info);
+ }
+ 
+ /* Guest modules initialisation */
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/52c1c78b5cefdee9807a1b29349a9cd3f38b2bee samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/52c1c78b5cefdee9807a1b29349a9cd3f38b2bee
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/52c1c78b5cefdee9807a1b29349a9cd3f38b2bee
@@ -0,0 +1,107 @@
+From 52c1c78b5cefdee9807a1b29349a9cd3f38b2bee Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Tue, 19 Apr 2016 07:33:03 +0200
+Subject: [PATCH 14/27] s3:libsmb: use anonymous authentication via spnego if
+ possible
+
+This makes the authentication consistent against between
+SMB1 with CAP_EXTENDED_SECURITY (introduced in Windows 2000)
+and SNB2.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/libsmb/cliconnect.c | 55 ++++++++++++++++++++++++---------------------
+ 1 file changed, 29 insertions(+), 26 deletions(-)
+
+diff --git source3/libsmb/cliconnect.c source3/libsmb/cliconnect.c
+index b984087..ea92c8f 100644
+--- source3/libsmb/cliconnect.c
++++ source3/libsmb/cliconnect.c
+@@ -1661,6 +1661,19 @@ static void cli_session_setup_gensec_ready(struct tevent_req *req)
+ 		}
+ 	}
+ 
++	if (state-&gt;is_anonymous) {
++		/*
++		 * Windows server does not set the
++		 * SMB2_SESSION_FLAG_IS_NULL flag.
++		 *
++		 * This fix makes sure we do not try
++		 * to verify a signature on the final
++		 * session setup response.
++		 */
++		tevent_req_done(req);
++		return;
++	}
++
+ 	status = gensec_session_key(state-&gt;auth_generic-&gt;gensec_security,
+ 				    state, &amp;state-&gt;session_key);
+ 	if (tevent_req_nterror(req, status)) {
+@@ -1670,20 +1683,6 @@ static void cli_session_setup_gensec_ready(struct tevent_req *req)
+ 	if (smbXcli_conn_protocol(state-&gt;cli-&gt;conn) &gt;= PROTOCOL_SMB2_02) {
+ 		struct smbXcli_session *session = state-&gt;cli-&gt;smb2.session;
+ 
+-		if (state-&gt;is_anonymous) {
+-			/*
+-			 * Windows server does not set the
+-			 * SMB2_SESSION_FLAG_IS_GUEST nor
+-			 * SMB2_SESSION_FLAG_IS_NULL flag.
+-			 *
+-			 * This fix makes sure we do not try
+-			 * to verify a signature on the final
+-			 * session setup response.
+-			 */
+-			tevent_req_done(req);
+-			return;
+-		}
+-
+ 		status = smb2cli_session_set_session_key(session,
+ 							 state-&gt;session_key,
+ 							 state-&gt;recv_iov);
+@@ -2121,6 +2120,21 @@ struct tevent_req *cli_session_setup_send(TALLOC_CTX *mem_ctx,
+ 		return req;
+ 	}
+ 
++	/*
++	 * if the server supports extended security then use SPNEGO
++	 * even for anonymous connections.
++	 */
++	if (smb1cli_conn_capabilities(cli-&gt;conn) &amp; CAP_EXTENDED_SECURITY) {
++		subreq = cli_session_setup_spnego_send(
++			state, ev, cli, user, pass, workgroup);
++		if (tevent_req_nomem(subreq, req)) {
++			return tevent_req_post(req, ev);
++		}
++		tevent_req_set_callback(subreq, cli_session_setup_done_spnego,
++					req);
++		return req;
++	}
++
+ 	/* if no user is supplied then we have to do an anonymous connection.
+ 	   passwords are ignored */
+ 
+@@ -2169,18 +2183,7 @@ struct tevent_req *cli_session_setup_send(TALLOC_CTX *mem_ctx,
+ 		return req;
+ 	}
+ 
+-	/* if the server supports extended security then use SPNEGO */
+-
+-	if (smb1cli_conn_capabilities(cli-&gt;conn) &amp; CAP_EXTENDED_SECURITY) {
+-		subreq = cli_session_setup_spnego_send(
+-			state, ev, cli, user, pass, workgroup);
+-		if (tevent_req_nomem(subreq, req)) {
+-			return tevent_req_post(req, ev);
+-		}
+-		tevent_req_set_callback(subreq, cli_session_setup_done_spnego,
+-					req);
+-		return req;
+-	} else {
++	{
+ 		/* otherwise do a NT1 style session setup */
+ 		if (lp_client_ntlmv2_auth() &amp;&amp; lp_client_use_spnego()) {
+ 			/*
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/7293e76a9cba375a1ad51145e27cdd5e1ea1667c samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/7293e76a9cba375a1ad51145e27cdd5e1ea1667c
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/7293e76a9cba375a1ad51145e27cdd5e1ea1667c
@@ -0,0 +1,57 @@
+From 7293e76a9cba375a1ad51145e27cdd5e1ea1667c Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 27 Apr 2016 01:44:56 +0200
+Subject: [PATCH 16/27] s4:auth_anonymous: anonymous authentication doesn't
+ allow a password
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source4/auth/ntlm/auth_anonymous.c | 30 ++++++++++++++++++++++++++++++
+ 1 file changed, 30 insertions(+)
+
+diff --git source4/auth/ntlm/auth_anonymous.c source4/auth/ntlm/auth_anonymous.c
+index 28cbfe8..ab1aac2 100644
+--- source4/auth/ntlm/auth_anonymous.c
++++ source4/auth/ntlm/auth_anonymous.c
+@@ -41,6 +41,36 @@ static NTSTATUS anonymous_want_check(struct auth_method_context *ctx,
+ 		return NT_STATUS_NOT_IMPLEMENTED;
+ 	}
+ 
++	switch (user_info-&gt;password_state) {
++	case AUTH_PASSWORD_PLAIN:
++		if (user_info-&gt;password.plaintext != NULL &amp;&amp;
++		    strlen(user_info-&gt;password.plaintext) &gt; 0)
++		{
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		break;
++	case AUTH_PASSWORD_HASH:
++		if (user_info-&gt;password.hash.lanman != NULL) {
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		if (user_info-&gt;password.hash.nt != NULL) {
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		break;
++	case AUTH_PASSWORD_RESPONSE:
++		if (user_info-&gt;password.response.lanman.length == 1) {
++			if (user_info-&gt;password.response.lanman.data[0] != '\0') {
++				return NT_STATUS_NOT_IMPLEMENTED;
++			}
++		} else if (user_info-&gt;password.response.lanman.length &gt; 1) {
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		if (user_info-&gt;password.response.nt.length &gt; 0) {
++			return NT_STATUS_NOT_IMPLEMENTED;
++		}
++		break;
++	}
++
+ 	return NT_STATUS_OK;
+ }
+ 
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/7d46392c30fade906c84867efd253e94999d1125 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/7d46392c30fade906c84867efd253e94999d1125
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/7d46392c30fade906c84867efd253e94999d1125
@@ -0,0 +1,109 @@
+From 78d9af9cbb28414c878aaa88edd379e063fc9646 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 20 Apr 2016 18:27:34 +0200
+Subject: [PATCH 21/27] auth/ntlmssp: do map to guest checking after the
+ authentication
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/ntlmssp/gensec_ntlmssp_server.c | 16 +--------------
+ auth/ntlmssp/ntlmssp_server.c        | 40 ++++++++++++++++++++++++++++++++++++
+ 2 files changed, 41 insertions(+), 15 deletions(-)
+
+diff --git auth/ntlmssp/gensec_ntlmssp_server.c auth/ntlmssp/gensec_ntlmssp_server.c
+index ca19863..120c6e0 100644
+--- auth/ntlmssp/gensec_ntlmssp_server.c
++++ auth/ntlmssp/gensec_ntlmssp_server.c
+@@ -130,21 +130,7 @@ NTSTATUS gensec_ntlmssp_server_start(struct gensec_security *gensec_security)
+ 		ntlmssp_state-&gt;allow_lm_key = true;
+ 	}
+ 
+-	if (lpcfg_map_to_guest(gensec_security-&gt;settings-&gt;lp_ctx) != NEVER_MAP_TO_GUEST) {
+-		/*
+-		 * map to guest is not secure anyway, so
+-		 * try to make it work and don't try to
+-		 * negotiate new_spnego and MIC checking
+-		 */
+-		ntlmssp_state-&gt;force_old_spnego = true;
+-	}
+-
+-	if (role == ROLE_ACTIVE_DIRECTORY_DC) {
+-		/*
+-		 * map to guest is not supported on an AD DC.
+-		 */
+-		ntlmssp_state-&gt;force_old_spnego = false;
+-	}
++	ntlmssp_state-&gt;force_old_spnego = false;
+ 
+ 	ntlmssp_state-&gt;neg_flags =
+ 		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_VERSION;
+diff --git auth/ntlmssp/ntlmssp_server.c auth/ntlmssp/ntlmssp_server.c
+index 17d5ade..ddee875 100644
+--- auth/ntlmssp/ntlmssp_server.c
++++ auth/ntlmssp/ntlmssp_server.c
+@@ -31,6 +31,9 @@
+ #include "auth/gensec/gensec.h"
+ #include "auth/gensec/gensec_internal.h"
+ #include "auth/common_auth.h"
++#include "param/param.h"
++#include "param/loadparm.h"
++#include "libcli/security/session.h"
+ 
+ /**
+  * Determine correct target name flags for reply, given server role
+@@ -698,6 +701,7 @@ static NTSTATUS ntlmssp_server_check_password(struct gensec_security *gensec_sec
+ 	struct ntlmssp_state *ntlmssp_state = gensec_ntlmssp-&gt;ntlmssp_state;
+ 	struct auth4_context *auth_context = gensec_security-&gt;auth_context;
+ 	NTSTATUS nt_status = NT_STATUS_NOT_IMPLEMENTED;
++	struct auth_session_info *session_info = NULL;
+ 	struct auth_usersupplied_info *user_info;
+ 
+ 	user_info = talloc_zero(ntlmssp_state, struct auth_usersupplied_info);
+@@ -734,6 +738,42 @@ static NTSTATUS ntlmssp_server_check_password(struct gensec_security *gensec_sec
+ 
+ 	NT_STATUS_NOT_OK_RETURN(nt_status);
+ 
++	if (lpcfg_map_to_guest(gensec_security-&gt;settings-&gt;lp_ctx) != NEVER_MAP_TO_GUEST
++	    &amp;&amp; auth_context-&gt;generate_session_info != NULL)
++	{
++		NTSTATUS tmp_status;
++
++		/*
++		 * We need to check if the auth is anonymous or mapped to guest
++		 */
++		tmp_status = auth_context-&gt;generate_session_info(auth_context, mem_ctx,
++								 gensec_ntlmssp-&gt;server_returned_info,
++								 gensec_ntlmssp-&gt;ntlmssp_state-&gt;user,
++								 AUTH_SESSION_INFO_SIMPLE_PRIVILEGES,
++								 &amp;session_info);
++		if (!NT_STATUS_IS_OK(tmp_status)) {
++			/*
++			 * We don't care about failures,
++			 * the worst result is that we try MIC checking
++			 * for a map to guest authentication.
++			 */
++			TALLOC_FREE(session_info);
++		}
++	}
++
++	if (session_info != NULL) {
++		if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
++			/*
++			 * Anonymous and GUEST are not secure anyway.
++			 * avoid new_spnego and MIC checking.
++			 */
++			ntlmssp_state-&gt;new_spnego = false;
++			ntlmssp_state-&gt;neg_flags &amp;= ~NTLMSSP_NEGOTIATE_SIGN;
++			ntlmssp_state-&gt;neg_flags &amp;= ~NTLMSSP_NEGOTIATE_SEAL;
++		}
++		TALLOC_FREE(session_info);
++	}
++
+ 	talloc_steal(mem_ctx, user_session_key-&gt;data);
+ 	talloc_steal(mem_ctx, lm_session_key-&gt;data);
+ 
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/810dca6074f179bfda045e6059650458d3bfa2fe samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/810dca6074f179bfda045e6059650458d3bfa2fe
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/810dca6074f179bfda045e6059650458d3bfa2fe
@@ -0,0 +1,55 @@
+From 810dca6074f179bfda045e6059650458d3bfa2fe Mon Sep 17 00:00:00 2001
+From: Uri Simchoni &lt;uri@samba.org&gt;
+Date: Mon, 18 Apr 2016 23:08:38 +0300
+Subject: [PATCH] libads: record session expiry for spnego sasl binds
+
+With the move to gensec-based spnego, record the session expiry
+in tgs_expire, so that libads users such as winbindd can use this info
+to determine how long to keep the connection.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11852
+
+Signed-off-by: Uri Simchoni &lt;uri@samba.org&gt;
+Reviewed-by: Andrew Bartlett &lt;abartlet@samba.org&gt;
+
+Autobuild-User(master): Uri Simchoni &lt;uri@samba.org&gt;
+Autobuild-Date(master): Tue Apr 19 16:53:57 CEST 2016 on sn-devel-144
+
+(cherry picked from commit 34482eb7cc3d74c8de510309332e8ab176d0f3c0)
+
+Autobuild-User(v4-3-test): Karolin Seeger &lt;kseeger@samba.org&gt;
+Autobuild-Date(v4-3-test): Tue Apr 26 15:33:37 CEST 2016 on sn-devel-104
+---
+ source3/libads/sasl.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git source3/libads/sasl.c source3/libads/sasl.c
+index 22aa9cf..b8d4527 100644
+--- source3/libads/sasl.c
++++ source3/libads/sasl.c
+@@ -134,6 +134,7 @@ static ADS_STATUS ads_sasl_spnego_gensec_bind(ADS_STRUCT *ads,
+ 	struct auth_generic_state *auth_generic_state;
+ 	bool use_spnego_principal = lp_client_use_spnego_principal();
+ 	const char *sasl_list[] = { sasl, NULL };
++	NTTIME end_nt_time;
+ 
+ 	nt_status = auth_generic_client_prepare(NULL, &amp;auth_generic_state);
+ 	if (!NT_STATUS_IS_OK(nt_status)) {
+@@ -307,6 +308,14 @@ static ADS_STATUS ads_sasl_spnego_gensec_bind(ADS_STRUCT *ads,
+ 		}
+ 	}
+ 
++	ads-&gt;auth.tgs_expire = LONG_MAX;
++	end_nt_time = gensec_expire_time(auth_generic_state-&gt;gensec_security);
++	if (end_nt_time != GENSEC_EXPIRE_TIME_INFINITY) {
++		struct timeval tv;
++		nttime_to_timeval(&amp;tv, end_nt_time);
++		ads-&gt;auth.tgs_expire = tv.tv_sec;
++	}
++
+ 	if (ads-&gt;ldap.wrap_type &gt; ADS_SASLWRAP_TYPE_PLAIN) {
+ 		size_t max_wrapped = gensec_max_wrapped_size(auth_generic_state-&gt;gensec_security);
+ 		ads-&gt;ldap.out.max_unwrapped = gensec_max_input_size(auth_generic_state-&gt;gensec_security);
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/8218185a00e691fa8f7691c906a5a0b65d52ff02 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/8218185a00e691fa8f7691c906a5a0b65d52ff02
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/8218185a00e691fa8f7691c906a5a0b65d52ff02
@@ -0,0 +1,49 @@
+From 8218185a00e691fa8f7691c906a5a0b65d52ff02 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 25 Apr 2016 15:58:27 +0200
+Subject: [PATCH 23/27] auth/ntlmssp: add
+ ntlmssp_{client,server}:force_old_spnego option for testing
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/ntlmssp/gensec_ntlmssp_server.c | 7 +++++++
+ auth/ntlmssp/ntlmssp_client.c        | 3 +++
+ 2 files changed, 10 insertions(+)
+
+diff --git auth/ntlmssp/gensec_ntlmssp_server.c auth/ntlmssp/gensec_ntlmssp_server.c
+index 120c6e0..99cedd0 100644
+--- auth/ntlmssp/gensec_ntlmssp_server.c
++++ auth/ntlmssp/gensec_ntlmssp_server.c
+@@ -132,6 +132,13 @@ NTSTATUS gensec_ntlmssp_server_start(struct gensec_security *gensec_security)
+ 
+ 	ntlmssp_state-&gt;force_old_spnego = false;
+ 
++	if (gensec_setting_bool(gensec_security-&gt;settings, "ntlmssp_server", "force_old_spnego", false)) {
++		/*
++		 * For testing Windows 2000 mode
++		 */
++		ntlmssp_state-&gt;force_old_spnego = true;
++	}
++
+ 	ntlmssp_state-&gt;neg_flags =
+ 		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_VERSION;
+ 
+diff --git auth/ntlmssp/ntlmssp_client.c auth/ntlmssp/ntlmssp_client.c
+index b423f20..5edd5f4 100644
+--- auth/ntlmssp/ntlmssp_client.c
++++ auth/ntlmssp/ntlmssp_client.c
+@@ -784,6 +784,9 @@ NTSTATUS gensec_ntlmssp_client_start(struct gensec_security *gensec_security)
+ 
+ 	ntlmssp_state-&gt;use_ntlmv2 = lpcfg_client_ntlmv2_auth(gensec_security-&gt;settings-&gt;lp_ctx);
+ 
++	ntlmssp_state-&gt;force_old_spnego = gensec_setting_bool(gensec_security-&gt;settings,
++						"ntlmssp_client", "force_old_spnego", false);
++
+ 	ntlmssp_state-&gt;expected_state = NTLMSSP_INITIAL;
+ 
+ 	ntlmssp_state-&gt;neg_flags =
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/82ab5c1b7c6382acb4fc39fd3e7b59be0ec5e157 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/82ab5c1b7c6382acb4fc39fd3e7b59be0ec5e157
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/82ab5c1b7c6382acb4fc39fd3e7b59be0ec5e157
@@ -0,0 +1,45 @@
+From 82ab5c1b7c6382acb4fc39fd3e7b59be0ec5e157 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Sat, 23 Apr 2016 05:17:25 +0200
+Subject: [PATCH 04/27] auth/spnego: handle broken mechListMIC response from
+ Windows 2000
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11870
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/gensec/spnego.c | 18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+diff --git auth/gensec/spnego.c auth/gensec/spnego.c
+index 2922478..f82d5bb 100644
+--- auth/gensec/spnego.c
++++ auth/gensec/spnego.c
+@@ -1078,6 +1078,24 @@ static NTSTATUS gensec_spnego_update(struct gensec_security *gensec_security, TA
+ 		}
+ 
+ 		if (spnego.negTokenTarg.mechListMIC.length &gt; 0) {
++			DATA_BLOB *m = &amp;spnego.negTokenTarg.mechListMIC;
++			const DATA_BLOB *r = &amp;spnego.negTokenTarg.responseToken;
++
++			/*
++			 * Windows 2000 has a bug, it repeats the
++			 * responseToken in the mechListMIC field.
++			 */
++			if (m-&gt;length == r-&gt;length) {
++				int cmp;
++
++				cmp = memcmp(m-&gt;data, r-&gt;data, m-&gt;length);
++				if (cmp == 0) {
++					data_blob_free(m);
++				}
++			}
++		}
++
++		if (spnego.negTokenTarg.mechListMIC.length &gt; 0) {
+ 			if (spnego_state-&gt;no_response_expected) {
+ 				spnego_state-&gt;needs_mic_check = true;
+ 			}
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/868c60155f39dd386b0448ad36e506b3d5d07e2b samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/868c60155f39dd386b0448ad36e506b3d5d07e2b
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/868c60155f39dd386b0448ad36e506b3d5d07e2b
@@ -0,0 +1,46 @@
+From 868c60155f39dd386b0448ad36e506b3d5d07e2b Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 18 Apr 2016 17:36:56 +0200
+Subject: [PATCH 19/27] s3:smbd: make use SMB_SETUP_GUEST constant
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/smbd/sesssetup.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git source3/smbd/sesssetup.c source3/smbd/sesssetup.c
+index b7fdd00..88cbf97 100644
+--- source3/smbd/sesssetup.c
++++ source3/smbd/sesssetup.c
+@@ -286,7 +286,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
+ 		}
+ 
+ 		if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
+-			action = 1;
++			action |= SMB_SETUP_GUEST;
+ 		}
+ 
+ 		if (session_info-&gt;session_key.length &gt; 0) {
+@@ -412,7 +412,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
+ 		}
+ 
+ 		if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
+-			action = 1;
++			action |= SMB_SETUP_GUEST;
+ 		}
+ 
+ 		/*
+@@ -940,7 +940,7 @@ void reply_sesssetup_and_X(struct smb_request *req)
+ 	}
+ 
+ 	if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
+-		action = 1;
++		action |= SMB_SETUP_GUEST;
+ 	}
+ 
+ 	/* register the name and uid as being validated, so further connections
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/9b4430122dd5cd22f6bfbe6441321268a06f6eae samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/9b4430122dd5cd22f6bfbe6441321268a06f6eae
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/9b4430122dd5cd22f6bfbe6441321268a06f6eae
@@ -0,0 +1,44 @@
+From 9b4430122dd5cd22f6bfbe6441321268a06f6eae Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 20 Apr 2016 18:44:21 +0200
+Subject: [PATCH 05/27] auth/ntlmssp: don't require any flags in the
+ ccache_resume code
+
+ntlmssp_client_challenge() already checks for required flags
+before asking winbindd.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11850
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ auth/ntlmssp/ntlmssp_client.c | 7 +------
+ 1 file changed, 1 insertion(+), 6 deletions(-)
+
+diff --git auth/ntlmssp/ntlmssp_client.c auth/ntlmssp/ntlmssp_client.c
+index b419615..8b367fc 100644
+--- auth/ntlmssp/ntlmssp_client.c
++++ auth/ntlmssp/ntlmssp_client.c
+@@ -172,19 +172,14 @@ NTSTATUS gensec_ntlmssp_resume_ccache(struct gensec_security *gensec_security,
+ 
+ 	if (ntlmssp_state-&gt;neg_flags &amp; NTLMSSP_NEGOTIATE_SIGN) {
+ 		gensec_security-&gt;want_features |= GENSEC_FEATURE_SIGN;
+-
+-		ntlmssp_state-&gt;required_flags |= NTLMSSP_NEGOTIATE_SIGN;
+ 	}
+ 
+ 	if (ntlmssp_state-&gt;neg_flags &amp; NTLMSSP_NEGOTIATE_SEAL) {
+ 		gensec_security-&gt;want_features |= GENSEC_FEATURE_SEAL;
+-
+-		ntlmssp_state-&gt;required_flags |= NTLMSSP_NEGOTIATE_SIGN;
+-		ntlmssp_state-&gt;required_flags |= NTLMSSP_NEGOTIATE_SEAL;
+ 	}
+ 
+-	ntlmssp_state-&gt;neg_flags |= ntlmssp_state-&gt;required_flags;
+ 	ntlmssp_state-&gt;conf_flags = ntlmssp_state-&gt;neg_flags;
++	ntlmssp_state-&gt;required_flags = 0;
+ 
+ 	if (DEBUGLEVEL &gt;= 10) {
+ 		struct NEGOTIATE_MESSAGE *negotiate = talloc(
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/aec3907f04a46aeda618a79cc6cbf8b830c94e65 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/aec3907f04a46aeda618a79cc6cbf8b830c94e65
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/aec3907f04a46aeda618a79cc6cbf8b830c94e65
@@ -0,0 +1,38 @@
+From aec3907f04a46aeda618a79cc6cbf8b830c94e65 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Fri, 22 Apr 2016 16:31:55 +0200
+Subject: [PATCH 03/27] s3:libads/sasl: allow wrapped messages up to a size of
+ 0xfffffff
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11872
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/libads/sasl.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git source3/libads/sasl.c source3/libads/sasl.c
+index b8d4527..10f63e8 100644
+--- source3/libads/sasl.c
++++ source3/libads/sasl.c
+@@ -319,7 +319,7 @@ static ADS_STATUS ads_sasl_spnego_gensec_bind(ADS_STRUCT *ads,
+ 		 * arcfour-hmac-md5.
+ 		 */
+ 		ads-&gt;ldap.in.min_wrapped = MIN(ads-&gt;ldap.out.sig_size, 0x2C);
+-		ads-&gt;ldap.in.max_wrapped = max_wrapped;
++		ads-&gt;ldap.in.max_wrapped = ADS_SASL_WRAPPING_IN_MAX_WRAPPED;
+ 		status = ads_setup_sasl_wrapping(ads, &amp;ads_sasl_gensec_ops, auth_generic_state-&gt;gensec_security);
+ 		if (!ADS_ERR_OK(status)) {
+ 			DEBUG(0, ("ads_setup_sasl_wrapping() failed: %s\n",
+@@ -977,7 +977,7 @@ static ADS_STATUS ads_sasl_gssapi_do_bind(ADS_STRUCT *ads, const gss_name_t serv
+ 
+ 		ads-&gt;ldap.out.sig_size = max_msg_size - ads-&gt;ldap.out.max_unwrapped;
+ 		ads-&gt;ldap.in.min_wrapped = 0x2C; /* taken from a capture with LDAP unbind */
+-		ads-&gt;ldap.in.max_wrapped = max_msg_size;
++		ads-&gt;ldap.in.max_wrapped = ADS_SASL_WRAPPING_IN_MAX_WRAPPED;
+ 		status = ads_setup_sasl_wrapping(ads, &amp;ads_sasl_gssapi_ops, context_handle);
+ 		if (!ADS_ERR_OK(status)) {
+ 			DEBUG(0, ("ads_setup_sasl_wrapping() failed: %s\n",
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/b2f7fdf24dd5be2995ef6e4349de819a25e35f9f samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/b2f7fdf24dd5be2995ef6e4349de819a25e35f9f
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/b2f7fdf24dd5be2995ef6e4349de819a25e35f9f
@@ -0,0 +1,55 @@
+From 9bdc20f1768c53aefe9eb2b72668260f305f3b35 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 27 Apr 2016 01:00:14 +0200
+Subject: [PATCH] selftest:Samba4: let fl2000dc use Windows2000
+ supported_enctypes
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ selftest/target/Samba.pm  | 13 +++++++++++++
+ selftest/target/Samba4.pm |  3 +++
+ 2 files changed, 16 insertions(+)
+
+diff --git selftest/target/Samba.pm selftest/target/Samba.pm
+index dabe442..069b85e 100644
+--- selftest/target/Samba.pm
++++ selftest/target/Samba.pm
+@@ -204,6 +204,19 @@ sub mk_krb5_conf($$)
+  forwardable = yes
+  allow_weak_crypto = yes
+ 
++";
++
++        if (defined($ctx-&gt;{supported_enctypes})) {
++		print KRB5CONF "
++ default_etypes = $ctx-&gt;{supported_enctypes}
++ default_as_etypes = $ctx-&gt;{supported_enctypes}
++ default_tgs_enctypes = $ctx-&gt;{supported_enctypes}
++ default_tkt_enctypes = $ctx-&gt;{supported_enctypes}
++ permitted_enctypes = $ctx-&gt;{supported_enctypes}
++";
++	}
++
++	print KRB5CONF "
+ [realms]
+  $our_realms_stanza
+  $other_realms_stanza
+diff --git selftest/target/Samba4.pm selftest/target/Samba4.pm
+index 22304a0..41422be 100755
+--- selftest/target/Samba4.pm
++++ selftest/target/Samba4.pm
+@@ -282,6 +282,9 @@ sub provision_raw_prepare($$$$$$$$$$)
+ 	$ctx-&gt;{swiface} = $swiface;
+ 	$ctx-&gt;{password} = $password;
+ 	$ctx-&gt;{kdc_ipv4} = $kdc_ipv4;
++	if ($functional_level eq "2000") {
++		$ctx-&gt;{supported_enctypes} = "arcfour-hmac-md5 des-cbc-md5 des-cbc-crc"
++	}
+ 
+ #
+ # Set smbd log level here.
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/cc8cadc07ced7fdcbc7c7f5fd186ba8e3e45a502 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/cc8cadc07ced7fdcbc7c7f5fd186ba8e3e45a502
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/cc8cadc07ced7fdcbc7c7f5fd186ba8e3e45a502
@@ -0,0 +1,64 @@
+From cc8cadc07ced7fdcbc7c7f5fd186ba8e3e45a502 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Mon, 18 Apr 2016 17:38:46 +0200
+Subject: [PATCH 11/27] libcli/smb: add smbXcli_session_is_guest() helper
+ function
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ libcli/smb/smbXcli_base.c | 24 ++++++++++++++++++++++++
+ libcli/smb/smbXcli_base.h |  1 +
+ 2 files changed, 25 insertions(+)
+
+diff --git libcli/smb/smbXcli_base.c libcli/smb/smbXcli_base.c
+index d8b85c8..4332374 100644
+--- libcli/smb/smbXcli_base.c
++++ libcli/smb/smbXcli_base.c
+@@ -4942,6 +4942,30 @@ struct smbXcli_session *smbXcli_session_copy(TALLOC_CTX *mem_ctx,
+ 	return session;
+ }
+ 
++bool smbXcli_session_is_guest(struct smbXcli_session *session)
++{
++	if (session == NULL) {
++		return false;
++	}
++
++	if (session-&gt;conn == NULL) {
++		return false;
++	}
++
++	if (session-&gt;conn-&gt;protocol &gt;= PROTOCOL_SMB2_02) {
++		if (session-&gt;smb2-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_GUEST) {
++			return true;
++		}
++		return false;
++	}
++
++	if (session-&gt;smb1.action &amp; SMB_SETUP_GUEST) {
++		return true;
++	}
++
++	return false;
++}
++
+ bool smbXcli_session_is_authenticated(struct smbXcli_session *session)
+ {
+ 	const DATA_BLOB *application_key;
+diff --git libcli/smb/smbXcli_base.h libcli/smb/smbXcli_base.h
+index 8eb482a..16c8848 100644
+--- libcli/smb/smbXcli_base.h
++++ libcli/smb/smbXcli_base.h
+@@ -371,6 +3,7 @@ struct smbXcli_session *smbXcli_session_create(TALLOC_CTX *mem_ctx,
+ 					       struct smbXcli_conn *conn);
+ struct smbXcli_session *smbXcli_session_copy(TALLOC_CTX *mem_ctx,
+ 					       struct smbXcli_session *src);
++bool smbXcli_session_is_guest(struct smbXcli_session *session);
+ bool smbXcli_session_is_authenticated(struct smbXcli_session *session);
+ NTSTATUS smbXcli_session_application_key(struct smbXcli_session *session,
+ 					 TALLOC_CTX *mem_ctx,
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/cc9db4b5c4fcbc2db37816ae0bb853dcc4607330 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/cc9db4b5c4fcbc2db37816ae0bb853dcc4607330
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/cc9db4b5c4fcbc2db37816ae0bb853dcc4607330
@@ -0,0 +1,48 @@
+From cc9db4b5c4fcbc2db37816ae0bb853dcc4607330 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Tue, 26 Apr 2016 08:50:00 +0200
+Subject: [PATCH 24/27] selftest:Samba4: provide DC_* variables for fl2000dc
+ and fl2008r2dc
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11849
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ selftest/target/Samba4.pm | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git selftest/target/Samba4.pm selftest/target/Samba4.pm
+index eddcfa6..369b142 100755
+--- selftest/target/Samba4.pm
++++ selftest/target/Samba4.pm
+@@ -1230,6 +1230,13 @@ sub provision_fl2000dc($$)
+ 		warn("Unable to add wins configuration");
+ 		return undef;
+ 	}
++	$ret-&gt;{DC_SERVER} = $ret-&gt;{SERVER};
++	$ret-&gt;{DC_SERVER_IP} = $ret-&gt;{SERVER_IP};
++	$ret-&gt;{DC_SERVER_IPV6} = $ret-&gt;{SERVER_IPV6};
++	$ret-&gt;{DC_NETBIOSNAME} = $ret-&gt;{NETBIOSNAME};
++	$ret-&gt;{DC_USERNAME} = $ret-&gt;{USERNAME};
++	$ret-&gt;{DC_PASSWORD} = $ret-&gt;{PASSWORD};
++	$ret-&gt;{DC_REALM} = $ret-&gt;{REALM};
+ 
+ 	return $ret;
+ }
+@@ -1230,6 +1237,13 @@ sub provision_fl2003dc($$$)
+ 		warn("Unable to add wins configuration");
+ 		return undef;
+ 	}
++	$ret-&gt;{DC_SERVER} = $ret-&gt;{SERVER};
++	$ret-&gt;{DC_SERVER_IP} = $ret-&gt;{SERVER_IP};
++	$ret-&gt;{DC_SERVER_IPV6} = $ret-&gt;{SERVER_IPV6};
++	$ret-&gt;{DC_NETBIOSNAME} = $ret-&gt;{NETBIOSNAME};
++	$ret-&gt;{DC_USERNAME} = $ret-&gt;{USERNAME};
++	$ret-&gt;{DC_PASSWORD} = $ret-&gt;{PASSWORD};
++	$ret-&gt;{DC_REALM} = $ret-&gt;{REALM};
+ 
+ 	return $ret;
+ }
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/dd29c36621b97495659cecc9c0c18e3704a5c747 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/dd29c36621b97495659cecc9c0c18e3704a5c747
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/dd29c36621b97495659cecc9c0c18e3704a5c747
@@ -0,0 +1,38 @@
+From dd29c36621b97495659cecc9c0c18e3704a5c747 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Tue, 19 Apr 2016 07:31:50 +0200
+Subject: [PATCH 07/27] s3:libsmb: use password = NULL for anonymous
+ connections
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11858
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/libsmb/cliconnect.c | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+
+diff --git source3/libsmb/cliconnect.c source3/libsmb/cliconnect.c
+index 2c351dd..b8a8c7a 100644
+--- source3/libsmb/cliconnect.c
++++ source3/libsmb/cliconnect.c
+@@ -1343,6 +1343,17 @@ static struct tevent_req *cli_session_setup_gensec_send(
+ 	talloc_set_destructor(
+ 		state, cli_session_setup_gensec_state_destructor);
+ 
++	if (user == NULL || strlen(user) == 0) {
++		if (pass != NULL &amp;&amp; strlen(pass) == 0) {
++			/*
++			 * some callers pass "" as no password
++			 *
++			 * gensec only handles NULL as no password.
++			 */
++			pass = NULL;
++		}
++	}
++
+ 	status = auth_generic_client_prepare(state, &amp;state-&gt;auth_generic);
+ 	if (tevent_req_nterror(req, status)) {
+ 		return tevent_req_post(req, ev);
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/e9a3cb95f121dc6604c39b8901f9d90413721de2 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/e9a3cb95f121dc6604c39b8901f9d90413721de2
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/e9a3cb95f121dc6604c39b8901f9d90413721de2
@@ -0,0 +1,62 @@
+From e9a3cb95f121dc6604c39b8901f9d90413721de2 Mon Sep 17 00:00:00 2001
+From: Alexander Bokovoy &lt;abokovoy@redhat.com&gt;
+Date: Tue, 12 Apr 2016 09:36:12 +0300
+Subject: [PATCH] s3-winbind: make sure domain member can talk to trusted
+ domains DCs
+
+  Allow cm_connect_netlogon() to talk to trusted domains' DCs when
+  running in a domain member configuration.
+
+  BUG: https://bugzilla.samba.org/show_bug.cgi?id=11830
+
+Signed-off-by: Alexander Bokovoy &lt;ab@samba.org&gt;
+---
+ source3/winbindd/winbindd_cm.c | 15 +++++++++------
+ 1 file changed, 9 insertions(+), 6 deletions(-)
+
+diff --git source3/winbindd/winbindd_cm.c source3/winbindd/winbindd_cm.c
+index 63175e5..1ef3d17 100644
+--- source3/winbindd/winbindd_cm.c
++++ source3/winbindd/winbindd_cm.c
+@@ -2578,9 +2578,10 @@ NTSTATUS cm_connect_sam(struct winbindd_domain *domain, TALLOC_CTX *mem_ctx,
+  anonymous:
+ 
+ 	/* Finally fall back to anonymous. */
+-	if (lp_winbind_sealed_pipes() || lp_require_strong_key()) {
++	if ((lp_winbind_sealed_pipes() || lp_require_strong_key()) &amp;&amp;
++	    (IS_DC || domain-&gt;primary)) {
+ 		status = NT_STATUS_DOWNGRADE_DETECTED;
+-		DEBUG(1, ("Unwilling to make SAMR connection to domain %s"
++		DEBUG(1, ("Unwilling to make SAMR connection to domain %s "
+ 			  "without connection level security, "
+ 			  "must set 'winbind sealed pipes = false' and "
+ 			  "'require strong key = false' to proceed: %s\n",
+@@ -2811,9 +2812,10 @@ NTSTATUS cm_connect_lsa(struct winbindd_domain *domain, TALLOC_CTX *mem_ctx,
+ 
+  anonymous:
+ 
+-	if (lp_winbind_sealed_pipes() || lp_require_strong_key()) {
++	if ((lp_winbind_sealed_pipes() || lp_require_strong_key()) &amp;&amp;
++	    (IS_DC || domain-&gt;primary)) {
+ 		result = NT_STATUS_DOWNGRADE_DETECTED;
+-		DEBUG(1, ("Unwilling to make LSA connection to domain %s"
++		DEBUG(1, ("Unwilling to make LSA connection to domain %s "
+ 			  "without connection level security, "
+ 			  "must set 'winbind sealed pipes = false' and "
+ 			  "'require strong key = false' to proceed: %s\n",
+@@ -2978,9 +2980,10 @@ NTSTATUS cm_connect_netlogon(struct winbindd_domain *domain,
+ 
+  no_schannel:
+ 	if (!(conn-&gt;netlogon_flags &amp; NETLOGON_NEG_AUTHENTICATED_RPC)) {
+-		if (lp_winbind_sealed_pipes() || lp_require_strong_key()) {
++		if ((lp_winbind_sealed_pipes() || lp_require_strong_key()) &amp;&amp;
++		    (IS_DC || domain-&gt;primary)) {
+ 			result = NT_STATUS_DOWNGRADE_DETECTED;
+-			DEBUG(1, ("Unwilling to make connection to domain %s"
++			DEBUG(1, ("Unwilling to make connection to domain %s "
+ 				  "without connection level security, "
+ 				  "must set 'winbind sealed pipes = false' and "
+ 				  "'require strong key = false' to proceed: %s\n",
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/f6b434f4134eda015430aeb81c10eac4f2eb722c samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/f6b434f4134eda015430aeb81c10eac4f2eb722c
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/f6b434f4134eda015430aeb81c10eac4f2eb722c
@@ -0,0 +1,34 @@
+From f6b434f4134eda015430aeb81c10eac4f2eb722c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?G=C3=BCnther=20Deschner?= &lt;gd@samba.org&gt;
+Date: Wed, 20 Apr 2016 20:09:53 +0200
+Subject: [PATCH 08/27] libcli/smb: fix NULL pointer derreference in
+ smbXcli_session_is_authenticated().
+
+Guenther
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Guenther Deschner &lt;gd@samba.org&gt;
+Reviewed-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ libcli/smb/smbXcli_base.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git libcli/smb/smbXcli_base.c libcli/smb/smbXcli_base.c
+index 6a71766..e502dc8 100644
+--- libcli/smb/smbXcli_base.c
++++ libcli/smb/smbXcli_base.c
+@@ -4945,6 +4945,10 @@ bool smbXcli_session_is_authenticated(struct smbXcli_session *session)
+ {
+ 	const DATA_BLOB *application_key;
+ 
++	if (session == NULL) {
++		return false;
++	}
++
+ 	if (session-&gt;conn == NULL) {
+ 		return false;
+ 	}
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/f9eb4e35949ff1b734197d7e8d49c12e1cd3875d samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/f9eb4e35949ff1b734197d7e8d49c12e1cd3875d
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/f9eb4e35949ff1b734197d7e8d49c12e1cd3875d
@@ -0,0 +1,69 @@
+From 82eb1fe5bd76ec3c7f1ed75f3618cf2a34be65b2 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Wed, 20 Apr 2016 16:34:28 +0200
+Subject: [PATCH] s3:smbd: only mark real guest sessions with the GUEST flag
+
+Real anonymous sessions don't get it.
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11847
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/smbd/sesssetup.c      | 6 +++---
+ source3/smbd/smb2_sesssetup.c | 7 ++++---
+ 2 files changed, 7 insertions(+), 6 deletions(-)
+
+diff --git source3/smbd/sesssetup.c source3/smbd/sesssetup.c
+index 1dbc180..77b8077 100644
+--- source3/smbd/sesssetup.c
++++ source3/smbd/sesssetup.c
+@@ -285,7 +285,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
+ 			return;
+ 		}
+ 
+-		if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
++		if (security_session_user_level(session_info, NULL) == SECURITY_GUEST) {
+ 			action |= SMB_SETUP_GUEST;
+ 		}
+ 
+@@ -411,7 +411,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
+ 			return;
+ 		}
+ 
+-		if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
++		if (security_session_user_level(session_info, NULL) == SECURITY_GUEST) {
+ 			action |= SMB_SETUP_GUEST;
+ 		}
+ 
+@@ -939,7 +939,7 @@ void reply_sesssetup_and_X(struct smb_request *req)
+ 		/* perhaps grab OS version here?? */
+ 	}
+ 
+-	if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
++	if (security_session_user_level(session_info, NULL) == SECURITY_GUEST) {
+ 		action |= SMB_SETUP_GUEST;
+ 	}
+ 
+diff --git source3/smbd/smb2_sesssetup.c source3/smbd/smb2_sesssetup.c
+index 8b239c9..c738856 100644
+--- source3/smbd/smb2_sesssetup.c
++++ source3/smbd/smb2_sesssetup.c
+@@ -202,11 +202,12 @@ static NTSTATUS smbd_smb2_auth_generic_return(struct smbXsrv_session *session,
+ 	}
+ 
+ 	if (security_session_user_level(session_info, NULL) &lt; SECURITY_USER) {
+-		/* we map anonymous to guest internally */
+-		*out_session_flags |= SMB2_SESSION_FLAG_IS_GUEST;
+-		*out_session_flags |= SMB2_SESSION_FLAG_IS_NULL;
++		if (security_session_user_level(session_info, NULL) == SECURITY_GUEST) {
++			*out_session_flags |= SMB2_SESSION_FLAG_IS_GUEST;
++		}
+ 		/* force no signing */
+ 		x-&gt;global-&gt;signing_required = false;
++		/* we map anonymous to guest internally */
+ 		guest = true;
+ 	}
+ 
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/samba.org/fdf4dcd19012c02fae9341d45a9ba6d682836232 samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/fdf4dcd19012c02fae9341d45a9ba6d682836232
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/samba.org/fdf4dcd19012c02fae9341d45a9ba6d682836232
@@ -0,0 +1,48 @@
+From fdf4dcd19012c02fae9341d45a9ba6d682836232 Mon Sep 17 00:00:00 2001
+From: Stefan Metzmacher &lt;metze@samba.org&gt;
+Date: Tue, 19 Apr 2016 07:20:28 +0200
+Subject: [PATCH 13/27] s3:libsmb: don't finish the gensec handshake for guest
+ logins
+
+BUG: https://bugzilla.samba.org/show_bug.cgi?id=11841
+
+Signed-off-by: Stefan Metzmacher &lt;metze@samba.org&gt;
+---
+ source3/libsmb/cliconnect.c | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+diff --git source3/libsmb/cliconnect.c source3/libsmb/cliconnect.c
+index 48f499c..b984087 100644
+--- source3/libsmb/cliconnect.c
++++ source3/libsmb/cliconnect.c
+@@ -1590,6 +1590,27 @@ static void cli_session_setup_gensec_remote_done(struct tevent_req *subreq)
+ 	}
+ 
+ 	if (NT_STATUS_IS_OK(status)) {
++		struct smbXcli_session *session = NULL;
++		bool is_guest = false;
++
++		if (smbXcli_conn_protocol(state-&gt;cli-&gt;conn) &gt;= PROTOCOL_SMB2_02) {
++			session = state-&gt;cli-&gt;smb2.session;
++		} else {
++			session = state-&gt;cli-&gt;smb1.session;
++		}
++
++		is_guest = smbXcli_session_is_guest(session);
++		if (is_guest) {
++			/*
++			 * We can't finish the gensec handshake, we don't
++			 * have a negotiated session key.
++			 *
++			 * So just pretend we are completely done.
++			 */
++			state-&gt;blob_in = data_blob_null;
++			state-&gt;local_ready = true;
++		}
++
+ 		state-&gt;remote_ready = true;
+ 	}
+ 
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/series samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/series
--- samba.2370/patches.tar.bz2/series
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/series
@@ -226,6 +226,36 @@
 samba.org/CVE-2016-2118.patch -p0 # bso 11616, bsc 971965
 samba.org/CVE-2015-5370.patch -p0 # bso 11344, bsc 936862
 samba.org/96331b20e36350056ffb9f52570c3ec7558e4c77 -p0 # bso 11744
+samba.org/e9a3cb95f121dc6604c39b8901f9d90413721de2 -p0 # bso 11830
+samba.org/285b7e3a1e3c3673a8b7439a1c96c5b44178078e -p0 # bso 11872
+samba.org/aec3907f04a46aeda618a79cc6cbf8b830c94e65 -p0 # bso 11872
+samba.org/82ab5c1b7c6382acb4fc39fd3e7b59be0ec5e157 -p0 # bso 11849, bso 11870
+samba.org/9b4430122dd5cd22f6bfbe6441321268a06f6eae -p0 # bso 11849, bso 11850
+samba.org/40ceb541057dbbfea497948c624b7a70c8540135 -p0 # bso 11849, bso 11850
+samba.org/dd29c36621b97495659cecc9c0c18e3704a5c747 -p0 # bso 11849, bso 11858
+samba.org/f6b434f4134eda015430aeb81c10eac4f2eb722c -p0 # bso 11849, bso 11841
+samba.org/3d3298731201cb38eddb4f43173d3592998f6a81 -p0 # bso 11849, bso 11841
+samba.org/2d69bcfa3a19d72ceecfd10f9632aea807424a3f -p0 # bso 11849, bso 11841
+samba.org/cc8cadc07ced7fdcbc7c7f5fd186ba8e3e45a502 -p0 # bso 11849, bso 11841
+samba.org/116b9aedc9cb4a0671a720e4e1ea14d57235c56b -p0 # bso 11849, bso 11841
+samba.org/fdf4dcd19012c02fae9341d45a9ba6d682836232 -p0 # bso 11849, bso 11841
+samba.org/52c1c78b5cefdee9807a1b29349a9cd3f38b2bee -p0 # bso 11849, bso 11841
+samba.org/2bc6a9c82fbb54793e121be862c7f617bfc3c063 -p0 # bso 11849, bso 11847
+samba.org/7293e76a9cba375a1ad51145e27cdd5e1ea1667c -p0 # bso 11849, bso 11847
+samba.org/5013b9ce4f87b4ebd806fbaf7660bceaa219fc4c -p0 # bso 11849, bso 11847
+samba.org/40484b3ae634e3ec7ac35ed0b362210f8f577faf -p0 # bso 11849, bso 11847
+samba.org/868c60155f39dd386b0448ad36e506b3d5d07e2b -p0 # bso 11849, bso 11847
+samba.org/f9eb4e35949ff1b734197d7e8d49c12e1cd3875d -p0 # bso 11849, bso 11847
+samba.org/7d46392c30fade906c84867efd253e94999d1125 -p0 # bso 11849, bso 11847
+samba.org/4a03836b3d6e5bb8b233c35aae916033acf21d7e -p0 # bso 11849
+samba.org/8218185a00e691fa8f7691c906a5a0b65d52ff02 -p0 # bso 11849
+samba.org/cc9db4b5c4fcbc2db37816ae0bb853dcc4607330 -p0 # bso 11849
+samba.org/4dc5f1504f790df5b54fe62cbe5e80481966f0fd -p0 # bso 11849
+samba.org/b2f7fdf24dd5be2995ef6e4349de819a25e35f9f -p0 # bso 11849
+samba.org/4fdc21e37451504d0d5cbb3a3d02e4bfcc728907 -p0 # bso 11849
+samba.org/0e398b83e6ec20266258d25b0960e09f1a8ef5f2 -p0 # bso 11849
+samba.org/810dca6074f179bfda045e6059650458d3bfa2fe -p0 # bso 11852, bsc 979268
+
 samba.org/fix_pc_dependencies.diff -p0
 
 # SuSE specific changes
@@ -239,3 +269,8 @@
 suse/0002-fsrvp-perform-old-version-0-database-upgrades.patch  -p0 # bnc 924519
 suse/0004-torture-test-FSRVP-server-state-V0-1-upgrades.patch -p0 # bnc 924519
 suse/0003-torture-add-db_version-0-FSRVP-state-storage-functio.patch -p0  # bnc 924519
+suse/0002-add-new-propagate-inheritance-option-for-smbcacls.patch -p0 # fate 316474
+suse/0003-doc-describe-smbcacls-propagate-inheritance.patch -p0 # fate 316474
+suse/0004-doc-describe-smbcacls-propagate-inheritance-expandin.patch -p0 # fate 316474
+suse/0001-add-smbcacls-test-based-on-test_smbclient_tarmode.pl.patch -p0 # fate 316474
+suse/0002-Adjust-test-cater-for-presense-of-winbind-separator-.patch -p0 # fate 316474
diff --bs samba.2370/patches.tar.bz2/suse/0001-add-smbcacls-test-based-on-test_smbclient_tarmode.pl.patch samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0001-add-smbcacls-test-based-on-test_smbclient_tarmode.pl.patch
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0001-add-smbcacls-test-based-on-test_smbclient_tarmode.pl.patch
@@ -0,0 +1,3128 @@
+From 96162e7222a9227b42856fca207b6c3ac8b81d25 Mon Sep 17 00:00:00 2001
+From: David Disseldorp &lt;ddiss@samba.org&gt;
+Date: Thu, 14 Nov 2013 16:10:26 +0000
+Subject: [PATCH] add smbcacls test based on test_smbclient_tarmode.pl
+
+Pair-Programmed-With: Noel Power &lt;noel.power@suse.com&gt;
+---
+ selftest/selftesthelpers.py           |    1 +
+ source3/script/tests/test_smbcacls.pl | 3061 +++++++++++++++++++++++++++++++++
+ source3/selftest/tests.py             |   22 +
+ 3 files changed, 3084 insertions(+)
+ create mode 100644 source3/script/tests/test_smbcacls.pl
+
+diff --git selftest/selftesthelpers.py selftest/selftesthelpers.py
+index a8aeab4..63a9787 100644
+--- selftest/selftesthelpers.py
++++ selftest/selftesthelpers.py
+@@ -220,6 +220,7 @@ def smbtorture4_testsuites(prefix):
+ 
+ 
+ smbclient3 = binpath('smbclient3')
++smbcacls = binpath('smbcacls')
+ smbtorture3 = binpath('smbtorture3')
+ ntlm_auth3 = binpath('ntlm_auth3')
+ net = binpath('net')
+diff --git source3/script/tests/test_smbcacls.pl source3/script/tests/test_smbcacls.pl
+new file mode 100644
+index 0000000..e58d9e5
+--- /dev/null
++++ source3/script/tests/test_smbcacls.pl
+@@ -0,0 +1,3061 @@
++#!/usr/bin/perl
++
++# Unix SMB/CIFS implementation.
++# Test suite for the smbcacls binary
++# Copyright (C) Aurlien Aptel 2013
++# Copyright (C) David Disseldorp 2013
++# Copyright (C) Noel Power 2013
++
++# This program is free software; you can redistribute it and/or modify
++# it under the terms of the GNU General Public License as published by
++# the Free Software Foundation; either version 3 of the License, or
++# (at your option) any later version.
++
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++
++# You should have received a copy of the GNU General Public License
++# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
++#
++# TODO - split all common test_smbcacls.pl/test_smbclient_tarmode.pl code into
++# a separate file.
++
++=head1 NAME
++
++C&lt;test_smbcacls.pl&gt; - Test for smbcacls
++
++=cut
++
++use v5.10;
++use strict;
++use warnings;
++
++use Archive::Tar;
++use Data::Dumper;
++use Digest::MD5 qw/md5_hex/;
++use File::Path qw/make_path remove_tree/;
++use File::Spec;
++use File::Temp;
++use Getopt::Long;
++use Pod::Usage;
++use Term::ANSIColor;
++
++sub d {print Dumper @_;}
++
++# DEFAULTS
++# 'our' to make them available in the File package
++our $USER      = '';
++our $PW        = '';
++our $HOST      = '';
++our $SHARE     = '';
++our $DIR       = 'tar_test_dir';
++our $LOCALPATH = '';
++our $TMP       = File::Temp-&gt;newdir();
++our $CLI_BIN   = 'smbclient';
++our $CACLS_BIN = 'smbcacls';
++our $SUBUNIT   = 0;
++
++my $SELECTED_TEST = '';
++my $LIST_TEST = 0;
++
++my @SMBARGS   = ();
++
++our $DEBUG = 1;
++our $VERBOSE = 1;
++my $MAN   = 0;
++my $HELP  = 0;
++my $CLEAN = 0;
++
++# all tests
++my @TESTS = (
++    ['simple, single file set ACL', \&amp;test_simple_single_set],
++    ['simple, single file modify ACL', \&amp;test_simple_single_mod],
++    ['simple, single file delete ACL', \&amp;test_simple_single_del],
++    ['simple, single file add ACL', \&amp;test_simple_single_add],
++    ['simple, single object inherit add', \&amp;test_simple_oi_add],
++    ['simple, single object inherit delete', \&amp;test_simple_oi_delete],
++    ['simple, single object inherit modify', \&amp;test_simple_oi_modify],
++    ['simple, single container inherit add', \&amp;test_simple_ci_add],
++    ['simple, single container inherit delete', \&amp;test_simple_ci_delete],
++    ['simple, single container inherit modify', \&amp;test_simple_ci_modify],
++    ['simple, single container/object inherit add', \&amp;test_simple_cioi_add],
++    ['simple, single container/object inherit delete', \&amp;test_simple_cioi_delete],
++    ['simple, single container/object inherit modify', \&amp;test_simple_cioi_modify],
++    ['simple, single inherit set(fail test)', \&amp;test_simple_set_fail],
++    ['simple, single container/object inherit set', \&amp;test_simple_oici_set],
++    ['simple, single container inherit set', \&amp;test_simple_ci_set],
++    ['simple, single container/inherit/np add', \&amp;test_simple_cioinp_add],
++    ['simple, single object inherit/np add', \&amp;test_simple_oinp_add],
++    ['simple, single container inherit/np add', \&amp;test_simple_cinp_add],
++    ['simple, single container/inherit/np delete', \&amp;test_simple_cioinp_delete],
++    ['simple, single object inherit/np delete', \&amp;test_simple_oinp_delete],
++    ['simple, single container inherit/np delete', \&amp;test_simple_cinp_delete],
++    ['simple, single container/object inherit inhibit', \&amp;test_simple_cioi_inhibit],
++);
++
++=head1 SYNOPSIS
++
++ test_smbcacls.pl [options] -- [smbclient options]
++
++ Options:
++    -h, --help    brief help message
++    --man         full documentation
++
++  Environment:
++    -u, --user      USER
++    -p, --password  PW
++    -n, --name      HOST	(required)
++    -s, --share     SHARE	(required)
++    -d, --dir       PATH
++        sub-path to use on the share
++
++    -l, --local-path  PATH	(required)
++        path to the root of the samba share on the machine.
++
++    --cli_bin       BIN
++        path to the smbclient binary to use
++
++    --cacls_bin     BIN
++        path to the smbcacls binary to use
++
++  Test:
++    --list
++       list tests
++
++    --test N
++    --test A-B
++    --test A,B,D-F
++       only run certain tests (accept list and intervals of numbers)
++
++    -v, --verbose
++       be more verbose
++
++    --debug
++       print command and their output (also set -v)
++
++    --subunit
++       print output in subunit format
++
++    --clean
++       clean out DIR path between tests
++
++=cut
++
++GetOptions('u|user=s'       =&gt; \$USER,
++           'p|password=s'   =&gt; \$PW,
++           'n|name=s'       =&gt; \$HOST,
++           's|share=s'      =&gt; \$SHARE,
++           'd|dir=s'        =&gt; \$DIR,
++           'l|local-path=s' =&gt; \$LOCALPATH,
++           'cli_bin=s'    =&gt; \$CLI_BIN,
++           'cacls_bin=s'  =&gt; \$CACLS_BIN,
++
++           'test=s'         =&gt; \$SELECTED_TEST,
++           'list'           =&gt; \$LIST_TEST,
++
++           'clean'          =&gt; \$CLEAN,
++           'subunit'        =&gt; \$SUBUNIT,
++           'debug'          =&gt; \$DEBUG,
++           'v|verbose'      =&gt; \$VERBOSE,
++           'h|help'         =&gt; \$HELP,
++           'man'            =&gt; \$MAN) or pod2usage(2);
++
++pod2usage(0) if $HELP;
++pod2usage(-exitval =&gt; 0, -verbose =&gt; 2) if $MAN;
++list_test(), exit 0 if $LIST_TEST;
++pod2usage(1) unless $HOST;
++pod2usage(1) unless $SHARE;
++pod2usage(1) unless $LOCALPATH;
++pod2usage(1) unless $USER;
++pod2usage(1) unless $PW;
++
++push @SMBARGS, '-U'.$USER.'%'.$PW;
++
++# remaining arguments are passed to smbclient
++push @SMBARGS, @ARGV;
++
++#####
++
++# SANITIZATION
++
++# remove all final slashes from input paths
++$LOCALPATH =~ s{[/\\]+$}{}g;
++$SHARE =~ s{[/\\]+$}{}g;
++$HOST =~ s{[/\\]+$}{}g;
++$DIR =~ s{[/\\]+$}{}g;
++# remove ./ prefix from DIR
++$DIR =~ s{^[\./\\]+}{}g;
++
++if (!-d $LOCALPATH) {
++    die "Local path '$LOCALPATH' is not a directory.\n";
++}
++
++if ($CLEAN) {
++    # clean the whole root first
++    remove_tree($LOCALPATH, { keep_root =&gt; 1 });
++}
++
++if ($DEBUG) {
++    $VERBOSE = 1;
++}
++
++#####
++
++# RUN TESTS
++
++my @selection = parse_test_string($SELECTED_TEST);
++
++if ($SELECTED_TEST eq '') {
++    run_test(@TESTS);
++} elsif (@selection &gt; 0) {
++    run_test(@selection);
++} else {
++    die "Test selection '$SELECTED_TEST' is invalid\n";
++}
++
++#################################
++
++=head1 DOCUMENTATION
++
++=head2 Defining a test
++
++=over
++
++=item * Create a function C&lt;test_yourtest&gt;
++
++=item * Use the File module, documented below
++
++=item * Use C&lt;smb_tar&gt;, C&lt;smb_client&gt;, C&lt;smb_cacls&gt;, C&lt;check_tar&gt; or C&lt;check_remote&gt;
++
++=item * Return number of errors
++
++=item * Add function to C&lt;@TESTS&gt;
++
++=back
++
++The function must be placed in the C&lt;@TESTS&gt; list along with a short
++description and optional arguments.
++
++=cut
++
++
++# test smbcacls '--set' attempts to overwrite the ACL for the file
++#
++# before:
++#
++#  +-tar_test_dir/
++#    +-file.1            (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/
++#    +-file.1            (F)
++#
++
++sub test_simple_single_set
++{
++	my @files;
++	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
++	my $ace;
++	my $ret;
++
++	my $f = File-&gt;new_local("$TMP/file-1");
++	$f-&gt;put_remote("file-1");
++
++	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++
++	# only a single ACE string in the ACL
++	$ace = ace_parse_str($acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++
++	$f-&gt;del_remote(1);
++
++	return 0;
++}
++
++
++# test smbcacls '--modify' attempts to modify the ACL for the file
++# (note: first part of the test 'set' ACL to (F) then attempts to modify
++# before:
++#
++#  +-tar_test_dir/
++#    +-file.1            (F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/
++#    +-file.1            (READ)
++#
++sub test_simple_single_mod
++{
++	my @files;
++	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
++	my $ace;
++	my $ret;
++
++	my $f = File-&gt;new_local("$TMP/file-1");
++	$f-&gt;put_remote("file-1");
++
++	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++
++	# only a single ACE string in the ACL
++	$ace = ace_parse_str($acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	# overwrite existing entry
++	$acl_str = "ACL:$USER:ALLOWED/0x0/READ";
++	smb_cacls('--modify', $acl_str, $f-&gt;smb_remotepath);
++	$ace = ace_parse_str($acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++
++	$f-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--delete' attempts to delete the ACL for the file
++# (note: first part of the test 'set' ACL to (F) then attempts to delete
++# before:
++#
++#  +-tar_test_dir/
++#    +-file.1            (F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/
++#    +-file.1            (none) - meaning no (F) ACL for this user
++#
++sub test_simple_single_del
++{
++	my @files;
++	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
++	my $ace;
++	my $ret;
++
++	my $f = File-&gt;new_local("$TMP/file-1");
++	$f-&gt;put_remote("file-1");
++
++	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++
++	# only a single ACE string in the ACL
++	$ace = ace_parse_str($acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	smb_cacls('--delete', $acl_str, $f-&gt;smb_remotepath);
++	$ace = ace_parse_str($acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++	if ($ret == 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++
++	$f-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--add' attempts to add the ACL for the file
++# (note: first part of the test 'set' ACL to (F) then attempts to add new ACL
++# before:
++#
++#  +-tar_test_dir/
++#    +-file.1            (F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/       
++#    +-file.1            (F,READ)
++#
++sub test_simple_single_add
++{
++	my @files;
++	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
++	my $dny_acl_str = "ACL:$USER:DENIED/0x0/READ";
++	my $ace;
++	my $ret;
++
++	my $f = File-&gt;new_local("$TMP/file-1");
++	$f-&gt;put_remote("file-1");
++
++	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++
++	# only a single ACE string in the ACL
++	$ace = ace_parse_str($acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++	if ($ret != 0) {
++		say "missing ace";
++		return 1;
++	}
++
++	smb_cacls('--add', $dny_acl_str, $f-&gt;smb_remotepath);
++	$ace = ace_parse_str($dny_acl_str);
++	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
++	if ($ret != 0) {
++		say "missing ace";
++		return 1;
++	}
++
++	$f-&gt;del_remote(1);
++
++	return 0;
++}
++
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (OI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (OI)(READ)
++#    | +-file.1            (I)(F), (I)(READ)
++#    | +-nested/      (OI)(CI)(I)(F), (OI)(IO)(I)(READ)
++#    |   +-file.2          (I)(F), (I)(READ)
++#
++
++sub test_simple_oi_add
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI/READ";
++	my $obj_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|IO|I/READ";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		say "missing ace";
++		return 1;
++	}
++	# file 'oi_dir/file-1' should  have inherited I/READ
++	$child_file_ace = ace_parse_str($obj_inherited_ace_str);
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++
++	if ($ret != 0) {
++		say "missing ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should have OI|IO/READ
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		say "missing ace";
++		return 1;
++	}
++
++	# nested file 'oi_dir/nested/file-2' should  have inherited I/READ
++	$ret = file_ace_check($f2-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (OI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (OI)(IO)(READ)
++#    | +-file.1            (I)(F), (I)(READ)
++#    | +-nested/      (OI)(CI)(I)(F), (OI)(IO)(I)(READ)
++#    |   +-file.2          (I)(F), (I)(READ)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++sub test_simple_oi_delete
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/OI/READ";
++	my $obj_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|IO|I/READ";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# add flags on oi_dir
++	smb_cacls('--add', $dir_acl_str,
++		$f1-&gt;smb_remotedir);
++	# add flags on oi_dir/nested
++	smb_cacls('--add', $dir_inherited_ace_str,
++		$f2-&gt;smb_remotedir);
++	# add flags on oi_dir/file-1
++	smb_cacls('--add', $obj_inherited_ace_str,
++		$f1-&gt;smb_remotepath);
++	# add flags on oi_dir/nested/file-2
++	smb_cacls('--add', $obj_inherited_ace_str,
++		$f2-&gt;smb_remotepath);
++
++	smb_cacls('--propagate-inheritance', '--delete', $dir_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' no longer has OI/READ
++	$dir_ace = ace_parse_str($dir_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++	# file 'oi_dir/file-1' should  no longer have inherited I/READ
++	$child_file_ace = ace_parse_str($obj_inherited_ace_str);
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should no longer have OI|IO/READ
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	# nested file 'oi_dir/nested/file-2' should no longer have inherited I/READ
++	$ret = file_ace_check($f2-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(READ)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F), (CI)((I)(READ)
++#    |   +-file.2          (I)(F)
++sub test_simple_ci_add
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/CI/READ";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/READ";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++	# check top level container 'oi_dir' has CI/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		say "missing ace";
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($file_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/READ
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should have CI|I|READ
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test delete an ACL with (CI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(READ)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F), (CI)((I)(READ)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++sub test_simple_ci_delete
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/CI/READ";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/READ";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# add flags on oi_dir
++	smb_cacls('--add', $dir_acl_str,
++		$f1-&gt;smb_remotedir);
++	# add flags on oi_dir/nested
++	smb_cacls('--add', $dir_inherited_ace_str,
++		$f2-&gt;smb_remotedir);
++	# make sure no (I|RX) flags on oi_dir/file-1
++	smb_cacls('--delete', $file_inherited_ace_str,
++		$f1-&gt;smb_remotepath);
++	# make sure no (I|RX) flags on oi_dir/nested/file-2
++	smb_cacls('--delete', $file_inherited_ace_str,
++		$f2-&gt;smb_remotepath);
++	smb_cacls('--propagate-inheritance', '--delete', $dir_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' no longer has CI/READ
++	$dir_ace = ace_parse_str($dir_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++
++	if ($ret == 0) {
++		say "unexpectex ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($file_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/READ
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should no longer have CI|I|READ
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(OI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(OI)READ)
++#    | +-file.1            (I)(F), (I)(READ)
++#    | +-nested/      (OI)(CI)(I)(F), (CI)(OI)(I)(READ)
++#    |   +-file.2          (I)(F), (I)(READ)
++sub test_simple_cioi_add
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI|CI/READ";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/READ";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI|CI/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($file_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should have inherited I/READ
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should have OI|CI|I|READ
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --delete' which attempts to delete the
++# ACL for the file and additionally use inheritance rules to propagate
++# appropriate changes to children
++#
++# This test deletes an ACL with (CI)(OI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(OI)(READ)
++#    | +-file.1            (I)(F), (I)(READ)
++#    | +-nested/      (OI)(CI)(I)(F), (CI)(OI)(I)(READ)
++#    |   +-file.2          (I)(F), (I)(READ)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++
++sub test_simple_cioi_delete
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/OI|CI/READ";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/READ";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# add flags on oi_dir
++	smb_cacls('--add', $dir_acl_str,
++		$f1-&gt;smb_remotedir);
++	# add flags on oi_dir/nested
++	smb_cacls('--add', $dir_inherited_ace_str,
++		$f2-&gt;smb_remotedir);
++	# add flags on oi_dir/file-1
++	smb_cacls('--add', $file_inherited_ace_str,
++		$f1-&gt;smb_remotepath);
++	# add flags on oi_dir/nested/file-2
++	smb_cacls('--add', $file_inherited_ace_str,
++		$f2-&gt;smb_remotepath);
++
++	smb_cacls('--propagate-inheritance', '--delete', $dir_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' no longer has OI|CI/READ
++	$dir_ace = ace_parse_str($dir_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($file_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/READ
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should no longer have OI|CI|I|READ
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret == 0) {
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --modify' which attempts to modify the
++# ACLfor the file and additionally use inheritance rules to propagate
++# appropriate changes to children
++#
++# This test first adds an ACL with (CI)(OI)(R), then it modifies that acl to be
++# (CI)(OI)(D) - where D == 0x00110000
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (CI)(OI)(R)
++#    | +-file.1       (I)(R)
++#    | +-nested/      (CI)(OI)(I)(R)
++#    |   +-file.2     (I)(R)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (CI)(OI)(D)
++#    | +-file.1       (I)(D)
++#    | +-nested/      (CI)(OI)(I)(D)
++#    |   +-file.2     (I)(D)
++
++sub test_simple_cioi_modify
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/OI|CI/R";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/R";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/R";
++	# 0x00110000 = D in icacls
++	my $dir_mod_acl_str = "ACL:$USER:ALLOWED/OI|CI/CHANGE";
++	my $file_mod_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_mod_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/CHANGE";
++
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# add flags on oi_dir
++
++	# This is somwhat artificial, we need to add a new acl to the directory
++	# so that the following modify operation doesn't fail. Previously
++	# '--modify' was used in place of '--add' but that resulted in failure
++	# to access the directory ( or even modify the acl ).
++	# Note: when running this test against a windows server it seems that
++	# running as Administrator ensures best results
++
++	smb_cacls('--add', $dir_acl_str,
++		$f1-&gt;smb_remotedir);
++	# add flags on oi_dir/nested
++	smb_cacls('--add', $dir_inherited_ace_str,
++		$f2-&gt;smb_remotedir);
++	# add flags on oi_dir/file-1
++	smb_cacls('--add', $file_inherited_ace_str,
++		$f1-&gt;smb_remotepath);
++	# add flags on oi_dir/nested/file-2
++	smb_cacls('--add', $file_inherited_ace_str,
++		$f2-&gt;smb_remotepath);
++	
++	smb_cacls('--propagate-inheritance', '--modify', $dir_mod_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI|CI/0x00110000
++	$dir_ace = ace_parse_str($dir_mod_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($file_mod_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should have inherited I/0x00110000
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should have OI|CI|I|0x00110000
++	$child_dir_ace = ace_parse_str($dir_mod_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++# test smbcacls '--propagate-inheritance --modify' which attempts to modify ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test first adds an ACL with (OI)(R), then it modifies that acl to be
++# (OI)(D) - where D == 0x00110000
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(IO)(R)
++#    | +-file.1       (I)(R)
++#    | +-nested/      (OI)(IO)(I)(R)
++#    |   +-file.2     (I)(R)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(IO)(D)
++#    | +-file.1       (I)(D)
++#    | +-nested/      (OI)(IO)(I)(D)
++#    |   +-file.2     (I)(D)
++sub test_simple_oi_modify
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/OI/READ";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|IO|I/READ";
++
++	# 0x00110000 = D in icacls
++	my $dir_mod_acl_str = "ACL:$USER:ALLOWED/OI/CHANGE";
++	my $file_mod_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_mod_inherited_ace_str = "ACL:$USER:ALLOWED/OI|IO|I/CHANGE";
++
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# add flags on oi_dir
++
++	# This is somwhat artificial, we need to add a new acl to the directory
++	# so that the following modify operation doesn't fail. Previously
++	# '--modify' was used in place of '--add' but that resulted in failure
++	# to access the directory ( or even modify the acl ).
++	# Note: when running this test against a windows server it seems that
++	# running as Administrator ensures best results
++
++	smb_cacls('--add', $dir_acl_str,
++		$f1-&gt;smb_remotedir);
++	# add flags on oi_dir/nested
++	smb_cacls('--add', $dir_inherited_ace_str,
++		$f2-&gt;smb_remotedir);
++	# add flags on oi_dir/file-1
++	smb_cacls('--add', $file_inherited_ace_str,
++		$f1-&gt;smb_remotepath);
++	# add flags on oi_dir/nested/file-2
++	smb_cacls('--add', $file_inherited_ace_str,
++		$f2-&gt;smb_remotepath);
++	
++	smb_cacls('--propagate-inheritance', '--modify', $dir_mod_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI/0x00110000
++	$dir_ace = ace_parse_str($dir_mod_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++	# file 'oi_dir/file-1' should  have inherited I/0x00110000
++	$child_file_ace = ace_parse_str($file_mod_inherited_ace_str);
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++
++	if ($ret != 0) {
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should have OI|IO/0x00110000
++	$child_dir_ace = ace_parse_str($dir_mod_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	# nested file 'oi_dir/nested/file-2' should  have inherited I/0x00110000
++	$ret = file_ace_check($f2-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++# test smbcacls '--propagate-inheritance --modify' which attempts to modify ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test first adds an ACL with (CI)(R), then it modifies that acl to be
++# (CI)(D) - where D == 0x00110000
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (CI)(R)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (CI)(I)(R)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (CI)(D)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (CI)(I)(D)
++#    |   +-file.2          (I)(F)
++
++sub test_simple_ci_modify
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/CI/READ";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/READ";
++
++	# 0x00110000 = D in icacls
++	my $dir_mod_acl_str = "ACL:$USER:ALLOWED/CI/CHANGE";
++	my $file_mod_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_mod_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/CHANGE";
++
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# add flags on oi_dir
++
++	# This is somwhat artificial, we need to add a new acl to the directory
++	# so that the following modify operation doesn't fail. Previously
++	# '--modify' was used in place of '--add' but that resulted in failure
++	# to access the directory ( or even modify the acl ).
++	# Note: when running this test against a windows server it seems that
++	# running as Administrator ensures best results
++
++	smb_cacls('--add', $dir_acl_str,
++		$f1-&gt;smb_remotedir);
++	# add flags on oi_dir/nested
++	smb_cacls('--add', $dir_inherited_ace_str,
++		$f2-&gt;smb_remotedir);
++
++        smb_cacls('--propagate-inheritance', '--modify', $dir_mod_acl_str,
++                $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has CI/0x00110000
++	$dir_ace = ace_parse_str($dir_mod_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($file_mod_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/0x00110000
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "got ace where not expecting";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should have OI|I|0x00110000
++	$child_dir_ace = ace_parse_str($dir_mod_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --set' which attempts to set the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(OI)(READ)
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++# fail, oid_dir has inheritance enabled, set should fail and exit with '1'
++
++sub test_simple_set_fail()
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/OI|CI/R";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/R";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/R";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++	my $out;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--set', $dir_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	if ($ret == 0 ) {
++		say "smb_cacls '--set' succeeded unexpectedly while processing container with inheritance enabled";	
++		return 1;
++	}
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --set' which attempts to set the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(OI)(RWD) additionally it removes 
++# inheritance from oi_dir
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(RWD)
++#    | +-file.1            (I)(RWD)
++#    | +-nested/      (OI)(CI)(I)(RWD)
++#    |   +-file.2          (I)(RWD)
++#
++
++sub test_simple_oici_set()
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/OI|CI/RWD";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/RWD";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/RWD";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++	my $out;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	($out, $ret) = smb_cacls('--inherit=copy', $f1-&gt;smb_remotedir);
++
++	# smb_cacls --inherit=remove 
++	if ($ret != 0 ) {
++		say "failed to remove inheritance enabled";	
++		return 1;
++	}
++
++	smb_cacls('--propagate-inheritance', '--set', $dir_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI|CI/RWD
++	$dir_ace = ace_parse_str($dir_acl_str);	
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++	# check nested file has I/RW
++	$child_file_ace = ace_parse_str($file_inherited_ace_str);	
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	# check nested dir has OI|CI|I/RW
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);	
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --set' which attempts to set the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(RWD) additionally it removes 
++# inheritance from oi_dir
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#  +-tar_test_dir/    (01)(CI)(I)(RWD)
++#    +-oi_dir/        (CI)(RWD)
++#    | +-file.1       
++#    | +-nested/      (CI)(I)(RWD)
++#    |   +-file.2     
++#
++
++sub test_simple_ci_set()
++{
++	my @files;
++	my $dir_acl_str = "ACL:$USER:ALLOWED/CI/RWD";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/RWD";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/RWD";
++	my $delete_ace_str = "ACL:$USER:ALLOWED/0x0/RWD";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++	my $out;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	($out, $ret) = smb_cacls('--inherit=copy', $f1-&gt;smb_remotedir);
++
++	# smb_cacls --inherit=remove 
++	if ($ret != 0 ) {
++		say "failed to remove inheritance enabled";	
++		return 1;
++	}
++	smb_cacls('--propagate-inheritance', '--set', $dir_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	my $nacl;
++	$nacl = num_acls_for_file($f1-&gt;smb_remotedir);
++
++	# Although there maybe a couple of users with associated acl(s)
++	# before set, after set there should only be 1 acl
++	if ($nacl != 1) {
++		say "unexpected number of acls ($nacl) after set";
++		return 1;
++	}
++
++	# check top level container 'oi_dir' has OI|CI/RWD
++	$dir_ace = ace_parse_str($dir_acl_str);	
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++	# note can't check file because it has no ACL ( due to CI )
++
++	# check nested dir has OI|CI|I/RWD
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);	
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++	# set some flags to allow us to delete the files
++	smb_cacls('--set', $delete_ace_str, $f1-&gt;smb_remotepath);
++	smb_cacls('--set', $delete_ace_str, $f2-&gt;smb_remotepath);
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(OI)(NP)(CHANGE)
++# (NP) - no propagation should not propagate the changes any further containers
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(OI)(NP)(CHANGE)
++#    | +-file.1            (I)(F), (I)(CHANGE)
++#    | +-nested/      (OI)(CI)(I)(F), (I)(CHANGE)
++#    |   +-file.2          (I)(F)
++sub test_simple_cioinp_add
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI|CI|NP/CHANGE";
++	my $inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI|CI|NP/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/file-1' should have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/file-2' should NOT have I/CHANGE
++	$child_dir_ace = ace_parse_str($inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotepath, $child_dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested dir 'oi_dir/nested' should have inherited I/CHANGE
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_file_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (OI)(NP)(CHANGE)
++# (NP) - no propagation should not propagate the changes any further containers
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (OI)(NP)(CHANGE)
++#    | +-file.1            (I)(F), (I)(CHANGE)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++sub test_simple_oinp_add
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI|NP/CHANGE";
++	my $inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI|NP/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/file-1' should have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested' should NOT have I/CHANGE
++	$child_dir_ace = ace_parse_str($inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/nested/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children
++#
++# This test adds an ACL with (CI)(NP)(CHANGE)
++# (NP) - no propagation should not propagate the changes any further containers
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(NP)(CHANGE)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F), (I)(CHANGE)
++#    |   +-file.2          (I)(F)
++sub test_simple_cinp_add
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/CI|NP/CHANGE";
++	my $inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has CI|NP/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested' should have I/CHANGE
++	$child_dir_ace = ace_parse_str($inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/nested/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --delete' which attempts to delete
++# the ACL for the file and additionally use inheritance rules to propagate
++# appropriate changes to children
++#
++# This test adds an ACL with (CI)(OI)(NP)(CHANGE)
++# (NP) - no propagation should not propagate the changes any further containers
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(OI)(NP)(CHANGE)
++#    | +-file.1            (I)(F), (I)(CHANGE)
++#    | +-nested/      (OI)(CI)(I)(F), (I)(CHANGE)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++sub test_simple_cioinp_delete
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI|CI|NP/CHANGE";
++	my $inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# set up 'before' permissions
++	smb_cacls('--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++	smb_cacls('--add', $inherited_ace_str,
++		  $f1-&gt;smb_remotepath);
++	smb_cacls('--add', $inherited_ace_str,
++		  $f2-&gt;smb_remotedir);
++
++	smb_cacls('--propagate-inheritance', '--delete', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' does NOT have OI|CI|NP/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested dir 'oi_dir/nested' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --delete' which attempts to delete the
++# ACL for the file and additionally use inheritance rules to propagate
++# appropriate changes to children
++#
++# This test adds an ACL with (CI)(NP)(CHANGE)
++# (NP) - no propagation should not propagate the changes any further containers
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(NP)(CHANGE)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F), (I)(CHANGE)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++
++sub test_simple_cinp_delete
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/CI|NP/CHANGE";
++	my $inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# set up ace(s) to match 'before'
++	smb_cacls('--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++	smb_cacls('--add', $inherited_ace_str,
++		  $f2-&gt;smb_remotedir);
++
++	smb_cacls('--propagate-inheritance', '--delete', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' doesn't have CI|NP/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested' should NOT have I/CHANGE
++	$child_dir_ace = ace_parse_str($inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/nested/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --delete' which attempts to delete the
++# ACL for the file and additionally use inheritance rules to propagate
++# appropriate changes to children
++#
++# This test adds an ACL with (OI)(NP)(CHANGE)
++# (NP) - no propagation should not propagate the changes any further containers
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (OI)(NP)(CHANGE)
++#    | +-file.1            (I)(F), (I)(CHANGE)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(I)(F)
++#    |   +-file.2          (I)(F)
++
++sub test_simple_oinp_delete
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI|NP/CHANGE";
++	my $inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	# set up 'before' permissions
++	smb_cacls('--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++	smb_cacls('--add', $inherited_ace_str,
++		  $f1-&gt;smb_remotepath);
++
++	smb_cacls('--propagate-inheritance', '--delete', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' does NOT have OI|NP/READ
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($inherited_ace_str);
++	# nested file 'oi_dir/file-1' should NOT have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++# test smbcacls '--propagate-inheritance --add' which attempts to add the ACL
++# for the file and additionally use inheritance rules to propagate appropriate
++# changes to children. In particular it tests that inheritance removed does
++# indeed prevent inheritance propagation
++#
++# This test adds an ACL with (CI)(OI)(CHANGE) at oi_dir
++#
++# Note: Inheritance has been removed ( and ace(s) copied ) at
++#   tar_test_dir/oi_dir/nested
++#
++# before:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F)
++#    | +-file.1            (I)(F)
++#    | +-nested/      (OI)(CI)(F)
++#    |   +-file.2          (I)(F)
++#
++# after/expected:
++#
++#  +-tar_test_dir/    (01)(CI)(I)(F)
++#    +-oi_dir/        (OI)(CI)(I)(F), (CI)(OI)(CHANGE)
++#    | +-file.1            (I)(F), (I)((CHANGE)
++#    | +-nested/      (OI)(CI)(F)
++#    |   +-file.2          (I)(F)
++sub test_simple_cioi_inhibit
++{
++	my @files;
++	my $dir_add_acl_str = "ACL:$USER:ALLOWED/OI|CI/CHANGE";
++	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
++	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/CHANGE";
++	my $dir_ace;
++	my $child_file_ace;
++	my $child_dir_ace;
++	my $ret;
++	my $out;
++
++	my $f1 = File-&gt;new_local("$TMP/file-1");
++	$f1-&gt;put_remote("oi_dir/file-1");
++	my $f2 = File-&gt;new_local("$TMP/file-2");
++	$f2-&gt;put_remote("oi_dir/nested/file-2");
++
++	($out, $ret) = smb_cacls('--inherit=copy', $f2-&gt;smb_remotedir);
++
++	# smb_cacls --inherit=remove 
++	if ($ret != 0 ) {
++		say "failed to remove inheritance enabled";	
++		return 1;
++	}
++
++	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
++		  $f1-&gt;smb_remotedir);
++
++	# check top level container 'oi_dir' has OI|CI/CHANGE
++	$dir_ace = ace_parse_str($dir_add_acl_str);
++	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++
++	$child_file_ace = ace_parse_str($file_inherited_ace_str);
++	# nested file 'oi_dir/file-1' should have inherited I/CHANGE
++	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
++	if ($ret != 0) {
++		say "missing expected ace";
++		return 1;
++	}
++
++	# nested dir  'oi_dir/nested/' should NOT have OI|CI|I/CHANGE
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++
++	# nested file  'oi_dir/nested/file-2' should NOT have I/CHANGE
++	$child_dir_ace = ace_parse_str($dir_inherited_ace_str);
++	$ret = file_ace_check($f2-&gt;smb_remotepath, $child_dir_ace);
++	if ($ret == 0) {
++		say "unexpected ace";
++		return 1;
++	}
++	$f1-&gt;del_remote();
++	$f2-&gt;del_remote(1);
++
++	return 0;
++}
++
++#################################
++
++# IMPLEMENTATION
++
++=head2 Useful functions
++
++Here are a list of useful functions and helpers to define tests.
++
++=cut
++
++# list test number and description
++sub list_test {
++    my $i = 0;
++    for (@TESTS) {
++        my ($desc, $f, @args) = @$_;
++        printf "%2d.\t%s\n", $i++, $desc;
++    }
++}
++
++sub run_test {
++    if ($SUBUNIT) {
++        run_test_subunit(@_);
++    } else {
++        run_test_normal(@_);
++    }
++}
++
++sub run_test_normal {
++    for (@_) {
++        my ($desc, $f, @args) = @$_;
++        my $err;
++
++        reset_env();
++        say "TEST: $desc";
++        if ($VERBOSE) {
++            $err = $f-&gt;(@args);
++        } else {
++            # turn off STDOUT
++            open my $saveout, "&gt;&amp;STDOUT";
++            open STDOUT, '&gt;', File::Spec-&gt;devnull();
++            $err = $f-&gt;(@args);
++            open STDOUT, "&gt;&amp;", $saveout;
++        }
++        print_res($err);
++        print "\n";
++    }
++    reset_env();
++}
++
++sub run_test_subunit {
++    for (@_) {
++        my ($desc, $f, @args) = @$_;
++        my $err;
++        my $str = '';
++
++        reset_env();
++        say "test: $desc";
++
++        # capture output in $buf
++        my $buf = '';
++        open my $handle, '&gt;', \$buf;
++        select $handle;
++
++        # check for die() calls
++        eval {
++            $err = $f-&gt;(@args);
++        };
++        if ($@) {
++            $str = $@;
++            $err = 1;
++        }
++        close $handle;
++
++        # restore output
++        select STDOUT;
++
++        # result string is output + eventual exception message
++        $str = $buf.$str;
++
++        printf "%s: %s [\n%s]\n", ($err &gt; 0 ? "failure" : "success"), $desc, $str;
++    }
++    reset_env();
++}
++
++sub parse_test_string {
++    my $s = shift;
++    my @tests = ();
++
++    if (!length($s)) {
++        return ();
++    }
++
++    for (split /,/, $s) {
++        if (/^\d+$/) {
++            if ($_ &gt;= @TESTS) {
++                return ();
++            }
++            push @tests, $TESTS[$_];
++        }
++        elsif (/^(\d+)-(\d+)$/) {
++            my ($min, $max) = sort ($1, $2);
++            if ($max &gt;= @TESTS) {
++                return ();
++            }
++
++            for ($min..$max) {
++                push @tests, $TESTS[$_];
++            }
++        }
++        else {
++            return ();
++        }
++    }
++
++    return @tests;
++}
++
++sub print_res {
++    my $err = shift;
++    if ($err) {
++        printf " RES: %s%d ERR%s\n", color('bold red'), $err, color 'reset';
++    } else {
++        printf " RES: %sOK%s\n", color('bold green'), color 'reset';
++    }
++}
++
++sub make_env {
++    my ($exts, $dirs) = @_;
++    my @all;
++    my $nb = 0;
++    for my $dir (@$dirs) {
++        for (@$exts) {
++            my $fn = $dir . "file$nb." . $_;
++            my $f = File-&gt;new_remote($fn, 'ABSPATH');
++            $f-&gt;delete_on_destruction(1);
++            push @all, $f;
++            $nb++;
++        }
++    }
++
++    @all;
++}
++
++=head3 C&lt;combine ( \@set, $n )&gt;
++
++=head3 C&lt;combine ( ['a', 'b', 'c'], 2 )&gt;
++
++Return a list of all possible I&lt;n&gt;-uplet (or combination of C&lt;$n&gt; element) of C&lt;@set&gt;.
++
++=cut
++sub combine {
++    my ($list, $n) = @_;
++    die "Insufficient list members" if $n &gt; @$list;
++
++    return map [$_], @$list if $n &lt;= 1;
++
++    my @comb;
++
++    for (my $i = 0; $i+$n &lt;= @$list; $i++) {
++        my $val = $list-&gt;[$i];
++        my @rest = @$list[$i+1..$#$list];
++        push @comb, [$val, @$_] for combine(\@rest, $n-1);
++    }
++
++    return @comb;
++}
++
++
++=head3 C&lt;reset_remote( )&gt;
++
++Remove all files in the server C&lt;$DIR&gt; (not root)
++
++=cut
++sub reset_remote {
++    # remove_tree($LOCALPATH . '/'. $DIR);
++    # make_path($LOCALPATH . '/'. $DIR);
++    if ($CLEAN) {
++	    remove_tree($LOCALPATH, {keep_root =&gt; 1});
++    }
++    make_path($LOCALPATH, {keep_root =&gt; 1});
++}
++
++=head3 C&lt;reset_tmp( )&gt;
++
++Remove all files in the temp directory C&lt;$TMP&gt;
++
++=cut
++sub reset_tmp {
++    remove_tree($TMP, { keep_root =&gt; 1 });
++}
++
++
++=head3 C&lt;reset_env( )&gt;
++
++Remove both temp and remote (C&lt;$DIR&gt;) files
++
++=cut
++sub reset_env {
++    reset_tmp();
++    reset_remote();
++}
++
++=head3 C&lt;file_list ( @files )&gt;
++
++Make a multiline string of all the files remote path, one path per line.
++
++C&lt;@files&gt; must be a list of C&lt;File&gt; instance.
++
++=cut
++sub file_list {
++    my @files = @_;
++    my $s = '';
++    for (@files) {
++        $s .= $_-&gt;remotepath."\n";
++    }
++    return $s;
++}
++
++# remove leading "./"
++sub remove_dot {
++    my $s = shift;
++    $s =~ s{^\./}{};
++    $s;
++}
++
++=head3 C&lt;check_remote( $remotepath, \@files )&gt;
++
++Check if C&lt;$remotepath&gt; has B&lt;exactly&gt; all the C&lt;@files&gt;.
++
++Print a summary on STDOUT.
++
++C&lt;@files&gt; must be a list of C&lt;File&gt; instance.
++
++=cut
++sub check_remote {
++    my ($subpath, $files) = @_;
++    my (%done, %expected);
++    my (@less, @more, @diff);
++
++    for (@$files) {
++        my $fn = remove_dot($_-&gt;remotepath);
++        $expected{$fn} = $_;
++        $done{$fn} = 0;
++    }
++
++    my %remote;
++    File::walk(sub { $remote{remove_dot($_-&gt;remotepath)} = $_ }, File::tree($subpath));
++
++    for my $rfile (sort keys %remote) {
++
++        # files that shouldn't be there
++        if (!exists $expected{$rfile}) {
++            say " +    $rfile";
++            push @more, $rfile;
++            next;
++        }
++
++        # same file multiple times
++        if ($done{$rfile} &gt; 0) {
++            $done{$rfile}++;
++            push @more, $rfile;
++            printf " +%3d %s\n", $done{$rfile}, $rfile;
++            next;
++        }
++
++        $done{$rfile}++;
++
++        # different file
++        my $rmd5 = $remote{$rfile}-&gt;md5;
++        if ($expected{$rfile}-&gt;md5 ne $rmd5) {
++            say " !    $rfile ($rmd5)";
++            push @diff, $rfile;
++            next;
++        }
++
++        say "      $rfile";
++    }
++
++    # file that should have been in tar
++    @less = grep { $done{$_} == 0 } sort keys %done;
++    for (@less) {
++        say " -    $_";
++    }
++
++    # summary
++    printf("\t%d files, +%d, -%d, !%d\n",
++           scalar keys %done,
++           scalar @more,
++           scalar @less,
++           scalar @diff);
++    return (@more + @less + @diff); # nb of errors
++}
++
++sub ace_dump
++{
++	my ($ace) = @_;
++	my $key;
++	my $value;
++
++	while (($key, $value) = each(%$ace)) {
++		print $key . "=" . $value . ", ";
++	}
++	print "\n";
++}
++
++sub ace_cmp
++{
++	my ($ace_left, $ace_right) = @_;
++	my $key;
++	my $value;
++	# need to copy hashes, otherwise entries are lost on failure!
++	my %ace1 = %$ace_left;
++	my %ace2 = %$ace_right;
++
++	while (($key, $value) = each(%ace1)) {
++		# ignore the users domain, only compare username
++		next if ($key eq "user_dom");
++
++		unless (defined $ace2{$key}) {
++			print "no entry for: $key\n";
++			return 1;
++		}
++		if ($value ne $ace2{$key}) {
++			print "mismatch: $key:$value != $key:$ace2{$key}\n";
++			return 1;
++		}
++	}
++
++	return 0;
++}
++
++=head3 C&lt;ace_parse_str( $ace_str )&gt;
++
++Parses the smbacls C&lt;$ace_str&gt; in the format of:
++	ACL:SAMBA-TEST\ddiss:ALLOWED/0x0/FULL
++The ACE is returned as hashref with the following members:
++-&gt;user_dom:	Domain assigned to ACE user, if any
++-&gt;user:		ACE user, without domain portion
++-&gt;type:		allow or deny
++-&gt;inherit:	inheritace flags
++-&gt;permissions:	permissions flags
++
++=cut
++sub ace_parse_str
++{
++	my ($ace_str) = @_;
++	my %ace;
++
++	my @splat = split(":", $ace_str);
++
++	if ($splat[0] ne "ACL") {
++		say "invalid ACE string: $ace_str";
++		return undef;
++	}
++
++	#check for domain component in username
++	if (index($splat[1], "\\") &gt;= 0) {
++		($ace{user_dom}, $ace{user}) = split(/\\/, $splat[1]);
++	} else {
++		$ace{user} = $splat[1];
++	}
++
++	($ace{type}, $ace{inherit}, $ace{permissions}) = split(/\//, $splat[2]);
++
++	return \%ace;
++}
++=head3 C&lt;num_acls_for_file( $file )&gt;
++
++count ACL that C&lt;$file&gt; has
++
++C&lt;$file&gt; must be a C&lt;File&gt; instance.
++
++=cut
++sub num_acls_for_file
++{
++	my ($file_remotepath) = @_;
++	my @aces;
++	my @out;
++	my ($output, $ret) =  smb_cacls("--get", $file_remotepath); 
++	@out = split("\n", $output);
++	@aces = grep(/^ACL/, @out);
++	return scalar @aces;
++}
++=head3 C&lt;file_ace_check( $file, $ace )&gt;
++
++Check that C&lt;$file&gt; has an ACE matching C&lt;$ace&gt;.
++
++C&lt;$file&gt; must be a C&lt;File&gt; instance.
++
++=cut
++sub file_ace_check
++{
++	my ($file_remotepath, $ace) = @_;
++	my $missing = 1;
++	my @aces;
++	my @out;
++	my ($output, $ret) =  smb_cacls("--get", $file_remotepath); 
++	@out = split("\n", $output);
++	@aces = grep(/^ACL/, @out);
++	# trim the domain portion of users
++	foreach (@aces) {
++		my $acl_ace = ace_parse_str($_);
++		return 1 unless defined $acl_ace;
++		# only compare aces for the same user and type
++		next unless (($acl_ace-&gt;{user} eq $ace-&gt;{user})
++			  &amp;&amp; ($acl_ace-&gt;{type} eq $ace-&gt;{type}));
++
++		say "found ACE for $acl_ace-&gt;{user}";
++		if (ace_cmp($acl_ace, $ace) != 0) {
++			print "differences between file ACE: ";
++			ace_dump($acl_ace);
++			print "and expected ACE: ";
++			ace_dump($ace);
++		}
++		else {
++			say "matched ACE for $acl_ace-&gt;{user}";
++			ace_dump($ace);
++			$missing = 0;
++			last;
++		}
++	}
++
++	return $missing;
++}
++
++=head3 C&lt;smb_client ( @args )&gt;
++
++Run smbclient with C&lt;@args&gt; passed as argument and return output.
++
++Each element of C&lt;@args&gt; becomes one escaped argument of smbclient.
++
++Host, share, user, password and the additionnal arguments provided on
++the command-line are already inserted.
++
++The output contains both the C&lt;STDOUT&gt; and C&lt;STDERR&gt;.
++
++Die if smbclient crashes or exits with an error code.
++
++=cut
++sub smb_client {
++    my (@args) = @_;
++
++    my $fullpath = "//$HOST/$SHARE";
++    my $cmd = sprintf("%s %s %s",
++                      quotemeta($CLI_BIN),
++                      quotemeta($fullpath),
++                      join(' ', map {quotemeta} (@SMBARGS, @args)));
++
++    if ($DEBUG) {
++        my $tmp = $cmd;
++        $tmp =~ s{\\([./+-])}{$1}g;
++        say color('bold yellow'), $tmp, color('reset');
++    }
++
++    my $out = `$cmd 2&gt;&amp;1`;
++    my $err = $?;
++    my $errstr = '';
++    # handle abnormal exit
++    if ($err == -1) {
++        $errstr = "failed to execute $cmd: $!\n";
++    }
++    elsif ($err &amp; 127) {
++        $errstr = sprintf "child died with signal %d (%s)\n", ($err &amp; 127), $cmd;
++    }
++    elsif ($err &gt;&gt; 8) {
++        $errstr = sprintf "child exited with value %d (%s)\n", ($err &gt;&gt; 8), $cmd;
++    }
++
++    if ($DEBUG) {
++        say $out;
++    }
++
++    if ($err) {
++        die "ERROR: $errstr";
++    }
++    return $out;
++}
++
++=head3 C&lt;smb_cacls ( @args )&gt;
++
++Run smbcacls with C&lt;@args&gt; passed as argument and return output.
++
++Each element of C&lt;@args&gt; becomes one escaped argument of smbcacls.
++
++Host, share, user, password and the additionnal arguments provided on
++the command-line are already inserted.
++
++The output contains both the C&lt;STDOUT&gt; and C&lt;STDERR&gt;.
++
++Die if smbcacls crashes or exits with an error code.
++
++=cut
++sub smb_cacls
++{
++	my (@args) = @_;
++
++	# last arg is the filename, share path must be immediately prior
++	my $file = pop(@args);
++	my $sharepath = "//$HOST/$SHARE";
++	my $cmd = sprintf("%s %s %s %s",
++			  quotemeta($CACLS_BIN),
++			  join(' ', map {quotemeta} (@SMBARGS, @args)),
++			  quotemeta($sharepath),
++			  quotemeta($file));
++
++	if ($DEBUG) {
++		my $tmp = $cmd;
++		$tmp =~ s{\\([./+-])}{$1}g;
++		say color('bold yellow'), $tmp, color('reset');
++	}
++
++	my $out = `$cmd 2&gt;&amp;1`;
++	my $err = $?;
++	my $errstr = '';
++	my $ret = 0;
++	# handle abnormal exit
++	if ($err == -1) {
++		$errstr = "failed to execute $cmd: $!\n";
++	} elsif ($err &amp; 127) {
++		$errstr = sprintf "child died with signal %d (%s)\n", ($err &amp; 127), $cmd;
++	} elsif ($err &gt;&gt; 8) {
++		$errstr = sprintf "child exited with value %d (%s)\n", ($err &gt;&gt; 8), $cmd;
++		$ret = ($err &gt;&gt; 8);
++	}
++
++	if ($DEBUG) {
++		say $out;
++	}
++
++	if ($err) {
++		# die for abnormal error (cmd didn't run or some signal caught)
++		die "ERROR: $errstr" if $ret == 0;
++	}
++	return ($out, $ret);
++}
++
++=head3 C&lt;random( $min, $max )&gt;
++
++Return integer in C&lt;[ $min ; $max ]&gt;
++
++=cut
++sub random {
++    my ($min, $max) = @_;
++    ($min, $max) = ($max, $min) if ($min &gt; $max);
++    $min + int(rand($max - $min));
++}
++
++#################################
++
++package File;
++
++=head2 The File module
++
++All the test should use the C&lt;File&gt; class. It has nice functions and
++methods to deal with paths, to create random files, to list the
++content of the server, to change attributes, etc.
++
++There are 2 kinds of C&lt;File&gt;: remote and local.
++
++=over
++
++=item * Remote files are accessible on the server.
++
++=item * Local files are not.
++
++=back
++
++Thus, some methods only works on remote files. If they do not make
++sense for local ones, they always return undef.
++
++=cut
++use File::Basename;
++use File::Path qw/make_path remove_tree/;
++use Digest::MD5 qw/md5_hex/;
++use Scalar::Util 'blessed';
++
++=head3 Constructors
++
++=head4 C&lt;&lt; File-&gt;new_remote($path [, $abs, $size]) &gt;&gt;
++
++Creates a file accessible on the server at C&lt;$DIR/$path&gt; ie. not at the
++root of the share and write C&lt;$size&gt; random bytes.
++
++If no size is provided, a random size is chosen.
++
++If you want to remove the automatic prefix C&lt;$DIR&gt;, set C&lt;$abs&gt; to 1.
++
++The file is created without any DOS attributes.
++
++If C&lt;$path&gt; contains non-existent directories, they are automatically
++created.
++
++=cut
++sub new_remote {
++    my ($class, $path, $abs, $size) = @_;
++    my ($file, $dir) = fileparse($path);
++
++    $dir = '' if $dir eq './';
++    my $loc;
++
++    if ($abs) {
++        $loc = cleanpath($main::LOCALPATH.'/'.$dir);
++    } else {
++        $dir = cleanpath($main::DIR.'/'.$dir);
++        $loc = cleanpath($main::LOCALPATH.'/'.$dir);
++    }
++
++    make_path($loc);
++
++    my $self = bless {
++        'attr' =&gt; {qw/r 0 s 0 h 0 a 0 d 0 n 0/},
++        'dir'  =&gt; $dir,
++        'name' =&gt; $file,
++        'md5'  =&gt; create_file($loc.'/'.$file, $size),
++        'remote' =&gt; 1,
++    }, $class;
++
++    $self-&gt;set_attr();
++
++    $self;
++}
++
++=head4 C&lt;&lt; File-&gt;new_local($abs_path [, $data]) &gt;&gt;
++
++Creates a file at C&lt;$abs_path&gt; with $data in it on the system.
++If $data is not provided, fill it with random bytes.
++
++=cut
++sub new_local {
++    my ($class, $path, $data) = @_;
++    my ($file, $dir) = fileparse($path);
++
++    make_path($dir);
++
++    my $md5;
++
++    if (defined $data) {
++        open my $f, '&gt;', $path or die "can't write in $path: $!";
++        print $f $data;
++        close $f;
++        $md5 = md5_hex($data);
++    } else {
++        $md5 = create_file($path);
++    }
++
++    my $self = {
++        'attr' =&gt; {qw/r 0 s 0 h 0 a 0 d 0 n 0/},
++        'dir'  =&gt; $dir,
++        'name' =&gt; $file,
++        'md5'  =&gt; $md5,
++        'remote' =&gt; 0,
++    };
++
++    bless $self, $class;
++}
++
++=head3 Methods
++
++=head4 C&lt;&lt; $f-&gt;localpath &gt;&gt;
++
++Return path on the system eg. F&lt;/opt/samba/share/test_tar_mode/file&gt;
++
++=cut
++sub localpath {
++    my $s = shift;
++    if ($s-&gt;{remote}) {
++        return cleanpath($main::LOCALPATH.'/'.$s-&gt;remotepath);
++    }
++    else {
++        return cleanpath($s-&gt;{dir}.'/'.$s-&gt;{name});
++    }
++}
++
++=head4 C&lt;&lt; $f-&gt;remotepath &gt;&gt;
++
++Return path on the server share.
++
++Return C&lt;undef&gt; if the file is local.
++
++=cut
++sub remotepath {
++    my ($s) = @_;
++    return undef if !$s-&gt;{remote};
++    my $r = $s-&gt;{dir}.'/'.$s-&gt;{name};
++    $r =~ s{^/}{};
++    return cleanpath($r);
++}
++
++=head4 C&lt;&lt; $f-&gt;smb_remotepath &gt;&gt;
++
++Return SMB path on the server share.
++
++Return C&lt;undef&gt; if the file is local.
++
++=cut
++sub smb_remotepath {
++    my ($s) = @_;
++    return undef if !$s-&gt;{remote};
++    my $r = $s-&gt;remotepath;
++    $r =~ s{/}{\\}g;
++    return $r;
++}
++
++=head4 C&lt;&lt; $f-&gt;remotedir &gt;&gt;
++
++Return the directory path of the file on the server.
++
++Like C&lt;&lt; $f-&gt;remotepath &gt;&gt; but without the final file name.
++
++=cut
++sub remotedir {
++    my $s = shift;
++    return undef if !$s-&gt;{remote};
++    cleanpath($s-&gt;{dir});
++}
++
++=head4 C&lt;&lt; $f-&gt;smb_remotepath &gt;&gt;
++
++Return SMB directory on the server share.
++
++Return C&lt;undef&gt; if the file is local.
++
++=cut
++sub smb_remotedir {
++    my ($s) = @_;
++    return undef if !$s-&gt;{remote};
++    my $r = $s-&gt;remotedir;
++    $r =~ s{/}{\\}g;
++    return $r;
++}
++
++=head4 C&lt;&lt; $f-&gt;tarpath &gt;&gt;
++
++Return path as it would appear in a tar archive.
++
++Like C&lt;&lt; $f-&gt;remotepath &gt;&gt; but prefixed with F&lt;./&gt;
++
++=cut
++sub tarpath {
++    my $s = shift;
++    return undef if !$s-&gt;{remote};
++    my $r = $s-&gt;remotepath;
++    $r =~ s{^\./+}{};
++    return $r;
++}
++
++=head4 C&lt;&lt; $f-&gt;delete_on_destruction( 0 ) &gt;&gt;
++
++=head4 C&lt;&lt; $f-&gt;delete_on_destruction( 1 ) &gt;&gt;
++
++By default, a C&lt;File&gt; is not deleted on the filesystem when it is not
++referenced anymore in Perl memory.
++
++When set to 1, the destructor unlink the file if it is not already removed.
++If the C&lt;File&gt; created directories when constructed, it does not remove them.
++
++=cut
++sub delete_on_destruction {
++    my ($s, $delete) = @_;
++    $s-&gt;{delete_on_destruction} = $delete;
++}
++
++=head4 C&lt;&lt; $f-&gt;set_attr( ) &gt;&gt;
++
++=head4 C&lt;&lt; $f-&gt;set_attr( 'a' ) &gt;&gt;
++
++=head4 C&lt;&lt; $f-&gt;set_attr( 'a', 'r', 's', 'h' ) &gt;&gt;
++
++Remove all DOS attributes and only set the one provided.
++
++=cut
++sub set_attr {
++    my ($s, @flags) = @_;
++    return undef if !$s-&gt;{remote};
++
++    $s-&gt;{attr} = {qw/r 0 s 0 h 0 a 0 d 0 n 0/};
++
++    for (@flags) {
++        $s-&gt;{attr}{lc($_)} = 1;
++    }
++
++    my $file = $s-&gt;{name};
++    my @args;
++    if ($s-&gt;remotedir) {
++        push @args, '-D', $s-&gt;remotedir;
++    }
++    main::smb_client(@args, '-c', qq{setmode "$file" -rsha});
++    if (@flags &amp;&amp; $flags[0] !~ /n/i) {
++        main::smb_client(@args, '-c', qq{setmode "$file" +}.join('', @flags));
++    }
++}
++
++=head4 C&lt;&lt; $f-&gt;attr_any( 'a' ) &gt;&gt;
++
++=head4 C&lt;&lt; $f-&gt;attr_any( 'a', 's', ... ) &gt;&gt;
++
++Return 1 if the file has any of the DOS attributes provided.
++
++=cut
++sub attr_any {
++    my ($s, @flags) = @_;
++    for (@flags) {
++        return 1 if $s-&gt;{attr}{$_};
++    }
++    0;
++}
++
++
++=head4 C&lt;&lt; $f-&gt;attr( 'a' ) &gt;&gt;
++
++=head4 C&lt;&lt; $f-&gt;attr( 'a', 's', ... ) &gt;&gt;
++
++Return 1 if the file has all the DOS attributes provided.
++
++=cut
++sub attr {
++    my ($s, @flags) = @_;
++    for (@flags) {
++        return 0 if !$s-&gt;{attr}{$_};
++    }
++    1;
++}
++
++=head4 C&lt;&lt; $f-&gt;attr_str &gt;&gt;
++
++Return DOS attributes as a compact string.
++
++  Read-only, hiden, system, archive =&gt; "rhsa"
++
++=cut
++sub attr_str {
++    my $s = shift;
++    return undef if !$s-&gt;{remote};
++    join('', map {$_ if $s-&gt;{attr}{$_}} qw/r h s a d n/);
++}
++
++=head4 C&lt;&lt; $f-&gt;set_time($t) &gt;&gt;
++
++Set modification and access time of the file to C&lt;$t&gt;.
++
++C&lt;$t&gt; must be in Epoch time (number of seconds since 1970/1/1).
++
++=cut
++sub set_time {
++    my ($s, $t) = @_;
++    utime $t, $t, $s-&gt;localpath;
++}
++
++=head4 C&lt;&lt; $f-&gt;md5 &gt;&gt;
++
++Return md5 sum of the file.
++
++The result is cached.
++
++=cut
++sub md5 {
++    my $s = shift;
++
++    if (!$s-&gt;{md5}) {
++        open my $h, '&lt;', $s-&gt;localpath() or die "can't read ".$s-&gt;localpath.": $!";
++        binmode $h;
++        $s-&gt;{md5} = Digest::MD5-&gt;new-&gt;addfile($h)-&gt;hexdigest;
++        close $h;
++    }
++
++    return $s-&gt;{md5};
++}
++
++=head4 C&lt;&lt; $f-&gt;put_remote($path, [$abs]) &gt;&gt;
++
++Transfers an existing local file to the server at C&lt;$DIR/$path&gt;.
++The local file is removed on success.
++
++=cut
++sub put_remote
++{
++	my ($s, $path, $abs) = @_;
++	my ($file, $dir) = fileparse($path);
++	my $remote_path = "";
++
++	return undef if $s-&gt;{remote};
++
++	$dir = '' if $dir eq './';
++	my $loc;
++
++	if ($abs) {
++		$loc = cleanpath($main::LOCALPATH.'/'.$dir);
++	} else {
++		$dir = cleanpath($main::DIR.'/'.$dir);
++		$loc = cleanpath($main::LOCALPATH.'/'.$dir);
++	}
++
++	if ($dir) {
++		foreach (split("\/", $dir)) {
++			$remote_path .= $_ . "\\";
++			main::smb_client('-c', qq{mkdir "$remote_path"});
++		}
++	}
++
++	$remote_path .= $file;
++	my $local_path = $s-&gt;localpath();
++	main::smb_client('-c', qq{put "$local_path" "$remote_path"});
++
++	$s-&gt;{dir} = $dir;
++	$s-&gt;{name} = $file;
++	$s-&gt;{remote} = 1;
++
++	return 0;
++}
++
++=head4 C&lt;&lt; $f-&gt;del_remote() &gt;&gt;
++
++Delete remote file.
++
++=cut
++sub del_remote
++{
++	my ($s, $rm_parent_dirs) = @_;
++
++	return 1 unless $s-&gt;{remote};
++
++	my $remote_path = $s-&gt;smb_remotepath;
++
++	main::smb_client('-c', qq{rm "$remote_path"});
++
++	unless ($rm_parent_dirs) {
++		return 0;
++	}
++
++	# attempt to remove all parent dirs
++	my @cmps = split(/\\/, $s-&gt;smb_remotedir);
++	while (scalar(@cmps) &gt; 0) {
++		my $path = join("\\", @cmps);
++		main::smb_client('-c', qq{rmdir "$path"});
++		pop(@cmps);
++	}
++
++	return 0;
++}
++
++sub DESTROY {
++    my $s = shift;
++    if ($s-&gt;{delete_on_destruction} &amp;&amp; -f $s-&gt;localpath) {
++        if ($main::DEBUG) {
++            say "DESTROY ".$s-&gt;localpath;
++        }
++        unlink $s-&gt;localpath;
++    }
++}
++
++=head3 Functions
++
++=head4 C&lt;&lt; File::walk( \&amp;function, @files) &gt;&gt;
++
++=head4 C&lt;&lt; File::walk( sub { ... }, @files) &gt;&gt;
++
++Iterate on file hierachy in C&lt;@files&gt; and return accumulated results.
++
++Use C&lt;$_&gt; in the sub to access the current C&lt;File&gt;.
++
++The C&lt;@files&gt; must come from a call to the C&lt;File::tree&gt; function.
++
++=cut
++sub walk {
++    my $fun = \&amp;{shift @_};
++
++    my @res;
++
++    for (@_) {
++        if ($_-&gt;{attr}{d}) {
++            push @res, walk($fun, @{$_-&gt;{content}});
++        } else {
++            push @res, $fun-&gt;($_);
++        }
++    }
++
++    return @res;
++}
++
++=head4 C&lt;&lt; File::list( $remotepath ) &gt;&gt;
++
++Return list of file (C&lt;File&gt; instance) in C&lt;$remotepath&gt;.
++
++C&lt;$remotepath&gt; must be a directory.
++
++=cut
++sub list {
++    my ($path) = @_;
++    $path ||= '/';
++    my @files;
++    my $out = main::smb_client('-D', $path, '-c', 'ls');
++    $path =~ s{^/}{};
++
++    for (split /\n/, $out) {
++        next if !/^  (.+?)\s+([AHSRDN]*)\s+(\d+)\s+(.+)/o;
++        my ($fn, $attr, $size, $date) = ($1, $2, $3, $4);
++        next if $fn =~ /^\.{1,2}$/;
++
++        push @files, bless {
++            'remote' =&gt; 1,
++            'dir'    =&gt; $path,
++            'name'   =&gt; $fn,
++            'size'   =&gt; int($size),
++            'date'   =&gt; $date,
++            'attr'   =&gt; {
++                # list context returns something different than the
++                # boolean matching result =&gt; force scalar context
++                'a' =&gt; scalar ($attr =~ /A/),
++                'h' =&gt; scalar ($attr =~ /H/),
++                's' =&gt; scalar ($attr =~ /S/),
++                'r' =&gt; scalar ($attr =~ /R/),
++                'd' =&gt; scalar ($attr =~ /D/),
++                'n' =&gt; scalar ($attr =~ /N/),
++            },
++        }, 'File';
++    }
++    return @files;
++}
++
++=head4 C&lt;&lt; File::tree( $remotepath ) &gt;&gt;
++
++Return recursive list of file in C&lt;$remotepath&gt;.
++
++C&lt;$remotepath&gt; must be a directory.
++
++Use C&lt;File::walk()&gt; to iterate over all the files.
++
++=cut
++sub tree {
++    my ($d) = @_;
++    my @files;
++
++    if (!defined $d) {
++        @files = list();
++    } elsif (blessed $d) {
++        @files = list($d-&gt;remotepath);
++    } else {
++        @files = list($d);
++    }
++
++    for my $f (@files) {
++        if ($f-&gt;{attr}{d}) {
++            $f-&gt;{content} = [tree($f)];
++        }
++    }
++
++    return @files;
++}
++
++# remove trailing or duplicated slash
++sub cleanpath {
++    my $p = shift;
++    $p =~ s{/+}{/}g;
++    $p =~ s{/$}{};
++    $p;
++}
++
++# create random file at path local path $fn
++sub create_file {
++    my ($fn, $size) = @_;
++    my $buf = '';
++    unlink $fn if -e $fn;
++    $size ||= main::random(512, 1024);
++    $size = int($size);
++    my $md5;
++
++    # try /dev/urandom, faster
++    if (-e '/dev/urandom') {
++        my $cmd = sprintf('head -c %d /dev/urandom | tee %s | md5sum',
++                          $size, quotemeta($fn));
++        $md5 = (split / /, `$cmd`)[0];
++    } else {
++        open my $out, '&gt;', $fn or die "can't open $fn: $!\n";
++        binmode $out;
++        for (1..$size) {
++            $buf .= pack('C', main::random(0, 256));
++        }
++        print $out $buf;
++        close $out;
++        $md5 = md5_hex($buf);
++    }
++    return $md5;
++}
++
++
++=head3 Examples
++
++    # create remote file in $DIR/foo/bar
++        my $f = File-&gt;new_remote("foo/bar/myfile");
++        say $f-&gt;localpath;  # /opt/share/$DIR/foo/bar/myfile
++        say $f-&gt;remotepath; # $DIR/foo/bar/myfile
++        say $f-&gt;remotedir;  # $DIR/foo/bar
++
++
++    # same but in root dir
++        my $f = File-&gt;new_remote("myfile", 1);
++        say $f-&gt;localpath;  # /opt/share/myfile
++        say $f-&gt;remotepath; # myfile
++        say $f-&gt;remotedir;  #
++
++
++    # create local random temp file in $TMP
++        my $f = File-&gt;new_local("$TMP/temp");
++        say $f-&gt;remotepath; # undef because it's not on the server
++
++
++    # same but file contains "hello"
++        my $f = File-&gt;new_local("$TMP/temp", "hello");
++
++
++    # list of files in $DIR (1 level)
++        for (File::list($DIR)) {
++            say $_-&gt;remotepath;
++        }
++
++
++    # list of all files in dir and subdir of $DIR
++        File::walk(sub { say $_-&gt;remotepath }, File::tree($DIR));
++
++=cut
++
++1;
+diff --git source3/selftest/tests.py source3/selftest/tests.py
+index 5d7346d..af41868 100755
+--- source3/selftest/tests.py
++++ source3/selftest/tests.py
+@@ -209,6 +209,28 @@ for env in ["s3dc"]:
+                        '-d', '$PREFIX', '-b', smbclient3,
+                        '--subunit', '--', configuration])
+ 
++    # Test smbcacls
++    smbcacls_test_args = [os.path.join(samba3srcdir, "script/tests/test_smbcacls.pl"),
++			  '-n', '$SERVER', '-s', 'tmp', '-u', '$USERNAME',
++			  '-p', '$PASSWORD', '-l', '$LOCAL_PATH', '-d', '$PREFIX',
++			  '--cli_bin=' + smbclient3, '-cacls_bin=' + smbcacls,
++			  '--subunit', '--clean']
++    smbcacls_subtests = ["file_set", "file_mod", "file_del", "file_add",
++			 "oi_add", "oi_del", "oi_mod",
++			 "ci_add", "ci_del", "ci_mod",
++			 "coi_add", "coi_del", "coi_mod",
++			 "inherit_set", "coi_set", "ci_set",
++			 "coinp_add", "oinp_add", "cinp_add",
++			 "coinp_delete", "oinp_delete", "cinp_delete",
++			 "coi_inhibit"]
++
++    i = 0
++    for cacls_subtest in smbcacls_subtests:
++	    plantestsuite("samba3.blackbox.smbcacls." + cacls_subtest + " (%s)"
++			  % env, env, smbcacls_test_args
++			  + ['--test', str(i), '--', configuration])
++	    i += 1
++
+ #TODO encrypted against member, with member creds, and with DC creds
+ plantestsuite("samba3.blackbox.net.misc", "s3dc:local",
+               [os.path.join(samba3srcdir, "script/tests/test_net_misc.sh"),
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/suse/0002-Adjust-test-cater-for-presense-of-winbind-separator-.patch samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0002-Adjust-test-cater-for-presense-of-winbind-separator-.patch
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0002-Adjust-test-cater-for-presense-of-winbind-separator-.patch
@@ -0,0 +1,872 @@
+From cd66690d751fbed3d070b55fe3b0b303aafa755a Mon Sep 17 00:00:00 2001
+From: Noel Power &lt;noel.power@suse.com&gt;
+Date: Wed, 22 Apr 2015 09:35:18 +0100
+Subject: [PATCH 2/2] Adjust test cater for presense of winbind separator = '/'
+ &amp; misc other fixes
+
++ add executable permissions on script
++ st/client/client.conf now contains the above as default, test was
+  assuming the seperator between 'domain' &amp; 'user' was '\'
++ make sure test_simple_ci_modify resets permissions correctly for cleanup
++ check return of smb_calc binary
++ correct some comments and text
++ ensure windows test can succeed without running as Administrator
++ test_simple_oi_modify fails on windows with access errors, running
+  as administrator doesn't see to have this issue. The test runs fine
+  on linux because it seems by default the linux share had already
+  explict 'FULL' permission set for the user. We mimic this here to
+  ensure test success for windows also.
+
+Signed-off-by: Noel Power &lt;noel.power@suse.com&gt;
+---
+ source3/script/tests/test_smbcacls.pl | 424 +++++++++++++++++++++++-----------
+ 1 file changed, 295 insertions(+), 129 deletions(-)
+ mode change 100644 =&gt; 100755 source3/script/tests/test_smbcacls.pl
+
+diff --git source3/script/tests/test_smbcacls.pl source3/script/tests/test_smbcacls.pl
+old mode 100644
+new mode 100755
+index e58d9e5..41bbc0b
+--- source3/script/tests/test_smbcacls.pl
++++ source3/script/tests/test_smbcacls.pl
+@@ -260,12 +260,15 @@ sub test_simple_single_set
+ 	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
+ 	my $ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f = File-&gt;new_local("$TMP/file-1");
+ 	$f-&gt;put_remote("file-1");
+ 
+-	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
+-
++	($out, $ret) = smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# only a single ACE string in the ACL
+ 	$ace = ace_parse_str($acl_str);
+ 	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
+@@ -294,12 +297,15 @@ sub test_simple_single_mod
+ 	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
+ 	my $ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f = File-&gt;new_local("$TMP/file-1");
+ 	$f-&gt;put_remote("file-1");
+ 
+-	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
+-
++	($out, $ret) = smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# only a single ACE string in the ACL
+ 	$ace = ace_parse_str($acl_str);
+ 	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
+@@ -309,7 +315,10 @@ sub test_simple_single_mod
+ 
+ 	# overwrite existing entry
+ 	$acl_str = "ACL:$USER:ALLOWED/0x0/READ";
+-	smb_cacls('--modify', $acl_str, $f-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--modify', $acl_str, $f-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	$ace = ace_parse_str($acl_str);
+ 	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
+ 
+@@ -336,7 +345,7 @@ sub test_simple_single_del
+ 	my $acl_str = "ACL:$USER:ALLOWED/0x0/FULL";
+ 	my $ace;
+ 	my $ret;
+-
++	my $out;
+ 	my $f = File-&gt;new_local("$TMP/file-1");
+ 	$f-&gt;put_remote("file-1");
+ 
+@@ -349,7 +358,10 @@ sub test_simple_single_del
+ 		return 1;
+ 	}
+ 
+-	smb_cacls('--delete', $acl_str, $f-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--delete', $acl_str, $f-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	$ace = ace_parse_str($acl_str);
+ 	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
+ 	if ($ret == 0) {
+@@ -381,12 +393,15 @@ sub test_simple_single_add
+ 	my $dny_acl_str = "ACL:$USER:DENIED/0x0/READ";
+ 	my $ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f = File-&gt;new_local("$TMP/file-1");
+ 	$f-&gt;put_remote("file-1");
+ 
+-	smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
+-
++	($out, $ret) = smb_cacls('--set', $acl_str, $f-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# only a single ACE string in the ACL
+ 	$ace = ace_parse_str($acl_str);
+ 	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
+@@ -395,7 +410,10 @@ sub test_simple_single_add
+ 		return 1;
+ 	}
+ 
+-	smb_cacls('--add', $dny_acl_str, $f-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $dny_acl_str, $f-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	$ace = ace_parse_str($dny_acl_str);
+ 	$ret = file_ace_check($f-&gt;smb_remotepath, $ace);
+ 	if ($ret != 0) {
+@@ -442,14 +460,18 @@ sub test_simple_oi_add
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+-	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--add',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' has OI/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -519,6 +541,7 @@ sub test_simple_oi_delete
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -526,20 +549,34 @@ sub test_simple_oi_delete
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+ 	# add flags on oi_dir
+-	smb_cacls('--add', $dir_acl_str,
+-		$f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested
+-	smb_cacls('--add', $dir_inherited_ace_str,
+-		$f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# add flags on oi_dir/file-1
+-	smb_cacls('--add', $obj_inherited_ace_str,
++	($out, $ret) = 	smb_cacls('--add', $obj_inherited_ace_str,
+ 		$f1-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested/file-2
+-	smb_cacls('--add', $obj_inherited_ace_str,
+-		$f2-&gt;smb_remotepath);
+-
+-	smb_cacls('--propagate-inheritance', '--delete', $dir_acl_str,
++	($out, $ret) = smb_cacls('--add', $obj_inherited_ace_str,
++				 $f2-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--delete',
++				 $dir_acl_str,
+ 		  $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' no longer has OI/READ
+ 	$dir_ace = ace_parse_str($dir_acl_str);
+@@ -608,13 +645,17 @@ sub test_simple_ci_add
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+-	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--add',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# check top level container 'oi_dir' has CI/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+@@ -676,6 +717,7 @@ sub test_simple_ci_delete
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -683,20 +725,34 @@ sub test_simple_ci_delete
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+ 	# add flags on oi_dir
+-	smb_cacls('--add', $dir_acl_str,
+-		$f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested
+-	smb_cacls('--add', $dir_inherited_ace_str,
+-		$f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# make sure no (I|RX) flags on oi_dir/file-1
+-	smb_cacls('--delete', $file_inherited_ace_str,
+-		$f1-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--delete', $file_inherited_ace_str,
++				 $f1-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# make sure no (I|RX) flags on oi_dir/nested/file-2
+-	smb_cacls('--delete', $file_inherited_ace_str,
+-		$f2-&gt;smb_remotepath);
+-	smb_cacls('--propagate-inheritance', '--delete', $dir_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--delete', $file_inherited_ace_str,
++				 $f2-&gt;smb_remotepath);
++	if ($ret != 0 ) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--delete',
++				 $dir_acl_str, $f1-&gt;smb_remotedir);
+ 
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# check top level container 'oi_dir' no longer has CI/READ
+ 	$dir_ace = ace_parse_str($dir_acl_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+@@ -759,15 +815,18 @@ sub test_simple_cioi_add
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+-	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
+-
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--add',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# check top level container 'oi_dir' has OI|CI/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+@@ -832,6 +891,7 @@ sub test_simple_cioi_delete
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -839,20 +899,35 @@ sub test_simple_cioi_delete
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+ 	# add flags on oi_dir
+-	smb_cacls('--add', $dir_acl_str,
+-		$f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested
+-	smb_cacls('--add', $dir_inherited_ace_str,
+-		$f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/file-1
+-	smb_cacls('--add', $file_inherited_ace_str,
+-		$f1-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $file_inherited_ace_str,
++				 $f1-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested/file-2
+-	smb_cacls('--add', $file_inherited_ace_str,
+-		$f2-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $file_inherited_ace_str,
++				 $f2-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	smb_cacls('--propagate-inheritance', '--delete', $dir_acl_str,
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--delete',
++				 $dir_acl_str,
+ 		  $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' no longer has OI|CI/READ
+ 	$dir_ace = ace_parse_str($dir_acl_str);
+@@ -902,10 +977,10 @@ sub test_simple_cioi_delete
+ # after/expected:
+ #
+ #  +-tar_test_dir/    (01)(CI)(I)(F)
+-#    +-oi_dir/        (CI)(OI)(D)
+-#    | +-file.1       (I)(D)
+-#    | +-nested/      (CI)(OI)(I)(D)
+-#    |   +-file.2     (I)(D)
++#    +-oi_dir/        (CI)(OI)(CHANGE)
++#    | +-file.1       (I)(CHANGE)
++#    | +-nested/      (CI)(OI)(I)(CHANGE)
++#    |   +-file.2     (I)(CHANGE)
+ 
+ sub test_simple_cioi_modify
+ {
+@@ -913,7 +988,7 @@ sub test_simple_cioi_modify
+ 	my $dir_acl_str = "ACL:$USER:ALLOWED/OI|CI/R";
+ 	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/R";
+ 	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/R";
+-	# 0x00110000 = D in icacls
++
+ 	my $dir_mod_acl_str = "ACL:$USER:ALLOWED/OI|CI/CHANGE";
+ 	my $file_mod_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
+ 	my $dir_mod_inherited_ace_str = "ACL:$USER:ALLOWED/OI|CI|I/CHANGE";
+@@ -922,6 +997,7 @@ sub test_simple_cioi_modify
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -937,22 +1013,37 @@ sub test_simple_cioi_modify
+ 	# Note: when running this test against a windows server it seems that
+ 	# running as Administrator ensures best results
+ 
+-	smb_cacls('--add', $dir_acl_str,
+-		$f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested
+-	smb_cacls('--add', $dir_inherited_ace_str,
+-		$f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/file-1
+-	smb_cacls('--add', $file_inherited_ace_str,
+-		$f1-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $file_inherited_ace_str,
++				 $f1-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested/file-2
+-	smb_cacls('--add', $file_inherited_ace_str,
+-		$f2-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $file_inherited_ace_str,
++				 $f2-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	
+-	smb_cacls('--propagate-inheritance', '--modify', $dir_mod_acl_str,
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--modify',
++				 $dir_mod_acl_str,
+ 		  $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	# check top level container 'oi_dir' has OI|CI/0x00110000
++	# check top level container 'oi_dir' has OI|CI/CHANGE
+ 	$dir_ace = ace_parse_str($dir_mod_acl_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+ 	if ($ret != 0) {
+@@ -960,14 +1051,14 @@ sub test_simple_cioi_modify
+ 	}
+ 
+ 	$child_file_ace = ace_parse_str($file_mod_inherited_ace_str);
+-	# nested file 'oi_dir/file-1' should have inherited I/0x00110000
++	# nested file 'oi_dir/file-1' should have inherited I|CHANGE
+ 	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
+ 	if ($ret != 0) {
+ 		say "missing expected ace";
+ 		return 1;
+ 	}
+ 
+-	# nested dir  'oi_dir/nested/' should have OI|CI|I|0x00110000
++	# nested dir  'oi_dir/nested/' should have OI|CI|I|CHANGE
+ 	$child_dir_ace = ace_parse_str($dir_mod_inherited_ace_str);
+ 	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
+ 	if ($ret != 0) {
+@@ -997,18 +1088,16 @@ sub test_simple_cioi_modify
+ # after/expected:
+ #
+ #  +-tar_test_dir/    (01)(CI)(I)(F)
+-#    +-oi_dir/        (OI)(IO)(D)
+-#    | +-file.1       (I)(D)
+-#    | +-nested/      (OI)(IO)(I)(D)
+-#    |   +-file.2     (I)(D)
++#    +-oi_dir/        (OI)(IO)(CHANGE)
++#    | +-file.1       (I)(CHANGED)
++#    | +-nested/      (OI)(IO)(I)(CHANGED)
++#    |   +-file.2     (I)(CHANGED)
+ sub test_simple_oi_modify
+ {
+ 	my @files;
+-	my $dir_acl_str = "ACL:$USER:ALLOWED/OI/READ";
+-	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
+-	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/OI|IO|I/READ";
++	my $explict_access_ace_str = "ACL:$USER:ALLOWED/0x0/RWD";
++
+ 
+-	# 0x00110000 = D in icacls
+ 	my $dir_mod_acl_str = "ACL:$USER:ALLOWED/OI/CHANGE";
+ 	my $file_mod_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
+ 	my $dir_mod_inherited_ace_str = "ACL:$USER:ALLOWED/OI|IO|I/CHANGE";
+@@ -1017,6 +1106,7 @@ sub test_simple_oi_modify
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -1032,28 +1122,42 @@ sub test_simple_oi_modify
+ 	# Note: when running this test against a windows server it seems that
+ 	# running as Administrator ensures best results
+ 
+-	smb_cacls('--add', $dir_acl_str,
+-		$f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $explict_access_ace_str,
++				 $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested
+-	smb_cacls('--add', $dir_inherited_ace_str,
+-		$f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $explict_access_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/file-1
+-	smb_cacls('--add', $file_inherited_ace_str,
+-		$f1-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $explict_access_ace_str,
++				 $f1-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested/file-2
+-	smb_cacls('--add', $file_inherited_ace_str,
+-		$f2-&gt;smb_remotepath);
+-	
+-	smb_cacls('--propagate-inheritance', '--modify', $dir_mod_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $explict_access_ace_str,
++				 $f2-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--modify',
++				 $dir_mod_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	# check top level container 'oi_dir' has OI/0x00110000
++	# check top level container 'oi_dir' has OI/CHANGE
+ 	$dir_ace = ace_parse_str($dir_mod_acl_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+ 	if ($ret != 0) {
+ 		return 1;
+ 	}
+-	# file 'oi_dir/file-1' should  have inherited I/0x00110000
++	# file 'oi_dir/file-1' should  have inherited I/CHANGE
+ 	$child_file_ace = ace_parse_str($file_mod_inherited_ace_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
+ 
+@@ -1061,14 +1165,14 @@ sub test_simple_oi_modify
+ 		return 1;
+ 	}
+ 
+-	# nested dir  'oi_dir/nested/' should have OI|IO/0x00110000
++	# nested dir  'oi_dir/nested/' should have OI|IO/CHANGE
+ 	$child_dir_ace = ace_parse_str($dir_mod_inherited_ace_str);
+ 	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
+ 	if ($ret != 0) {
+ 		return 1;
+ 	}
+ 
+-	# nested file 'oi_dir/nested/file-2' should  have inherited I/0x00110000
++	# nested file 'oi_dir/nested/file-2' should  have inherited I/CHANGE
+ 	$ret = file_ace_check($f2-&gt;smb_remotepath, $child_file_ace);
+ 	if ($ret != 0) {
+ 		say "got ace where not expecting";
+@@ -1098,9 +1202,9 @@ sub test_simple_oi_modify
+ # after/expected:
+ #
+ #  +-tar_test_dir/    (01)(CI)(I)(F)
+-#    +-oi_dir/        (CI)(D)
++#    +-oi_dir/        (CI)(CHANGE)
+ #    | +-file.1            (I)(F)
+-#    | +-nested/      (CI)(I)(D)
++#    | +-nested/      (CI)(I)(CHANGE)
+ #    |   +-file.2          (I)(F)
+ 
+ sub test_simple_ci_modify
+@@ -1110,15 +1214,16 @@ sub test_simple_ci_modify
+ 	my $file_inherited_ace_str = "ACL:$USER:ALLOWED/I/READ";
+ 	my $dir_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/READ";
+ 
+-	# 0x00110000 = D in icacls
+ 	my $dir_mod_acl_str = "ACL:$USER:ALLOWED/CI/CHANGE";
+ 	my $file_mod_inherited_ace_str = "ACL:$USER:ALLOWED/I/CHANGE";
+ 	my $dir_mod_inherited_ace_str = "ACL:$USER:ALLOWED/CI|I/CHANGE";
++	my $delete_ace_str = "ACL:$USER:ALLOWED/0x0/RWD";
+ 
+ 	my $dir_ace;
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -1134,16 +1239,24 @@ sub test_simple_ci_modify
+ 	# Note: when running this test against a windows server it seems that
+ 	# running as Administrator ensures best results
+ 
+-	smb_cacls('--add', $dir_acl_str,
+-		$f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 	# add flags on oi_dir/nested
+-	smb_cacls('--add', $dir_inherited_ace_str,
+-		$f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-        smb_cacls('--propagate-inheritance', '--modify', $dir_mod_acl_str,
+-                $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--modify',
++				 $dir_mod_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	# check top level container 'oi_dir' has CI/0x00110000
++	# check top level container 'oi_dir' has CI/CHANGE
+ 	$dir_ace = ace_parse_str($dir_mod_acl_str);
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+ 	if ($ret != 0) {
+@@ -1152,20 +1265,23 @@ sub test_simple_ci_modify
+ 
+ 
+ 	$child_file_ace = ace_parse_str($file_mod_inherited_ace_str);
+-	# nested file 'oi_dir/file-1' should NOT have inherited I/0x00110000
++	# nested file 'oi_dir/file-1' should NOT have inherited I/CHANGE
+ 	$ret = file_ace_check($f1-&gt;smb_remotepath, $child_file_ace);
+ 	if ($ret == 0) {
+ 		say "got ace where not expecting";
+ 		return 1;
+ 	}
+ 
+-	# nested dir  'oi_dir/nested/' should have OI|I|0x00110000
++	# nested dir  'oi_dir/nested/' should have OI|I/CHANGE
+ 	$child_dir_ace = ace_parse_str($dir_mod_inherited_ace_str);
+ 	$ret = file_ace_check($f2-&gt;smb_remotedir, $child_dir_ace);
+ 	if ($ret != 0) {
+ 		return 1;
+ 	}
+ 
++	# set some flags to allow us to delete the files
++	smb_cacls('--set', $delete_ace_str, $f1-&gt;smb_remotepath);
++	smb_cacls('--set', $delete_ace_str, $f2-&gt;smb_remotepath);
+ 	$f1-&gt;del_remote();
+ 	$f2-&gt;del_remote(1);
+ 
+@@ -1206,8 +1322,8 @@ sub test_simple_set_fail()
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+-	($out, $ret) = smb_cacls('--propagate-inheritance', '--set', $dir_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--set',
++				 $dir_acl_str, $f1-&gt;smb_remotedir);
+ 
+ 	if ($ret == 0 ) {
+ 		say "smb_cacls '--set' succeeded unexpectedly while processing container with inheritance enabled";	
+@@ -1266,9 +1382,11 @@ sub test_simple_oici_set()
+ 		return 1;
+ 	}
+ 
+-	smb_cacls('--propagate-inheritance', '--set', $dir_acl_str,
+-		  $f1-&gt;smb_remotedir);
+-
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--set',
++				 $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0 ) {
++		return 1;
++	}
+ 	# check top level container 'oi_dir' has OI|CI/RWD
+ 	$dir_ace = ace_parse_str($dir_acl_str);	
+ 	$ret = file_ace_check($f1-&gt;smb_remotedir, $dir_ace);
+@@ -1341,8 +1459,11 @@ sub test_simple_ci_set()
+ 		say "failed to remove inheritance enabled";	
+ 		return 1;
+ 	}
+-	smb_cacls('--propagate-inheritance', '--set', $dir_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--set',
++				 $dir_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	my $nacl;
+ 	$nacl = num_acls_for_file($f1-&gt;smb_remotedir);
+@@ -1408,14 +1529,18 @@ sub test_simple_cioinp_add
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+-	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--add',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' has OI|CI|NP/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -1486,14 +1611,18 @@ sub test_simple_oinp_add
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+-	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--add',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' has OI|NP/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -1564,14 +1693,18 @@ sub test_simple_cinp_add
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+ 	my $f2 = File-&gt;new_local("$TMP/file-2");
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+-	smb_cacls('--propagate-inheritance', '--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--add',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' has CI|NP/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -1642,6 +1775,7 @@ sub test_simple_cioinp_delete
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -1649,15 +1783,27 @@ sub test_simple_cioinp_delete
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+ 	# set up 'before' permissions
+-	smb_cacls('--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
+-	smb_cacls('--add', $inherited_ace_str,
+-		  $f1-&gt;smb_remotepath);
+-	smb_cacls('--add', $inherited_ace_str,
+-		  $f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--add', $inherited_ace_str,
++				 $f1-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--add', $inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	smb_cacls('--propagate-inheritance', '--delete', $dir_add_acl_str,
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--delete',
++				 $dir_add_acl_str,
+ 		  $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' does NOT have OI|CI|NP/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -1722,6 +1868,7 @@ sub test_simple_cinp_delete
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -1729,13 +1876,21 @@ sub test_simple_cinp_delete
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+ 	# set up ace(s) to match 'before'
+-	smb_cacls('--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
+-	smb_cacls('--add', $inherited_ace_str,
+-		  $f2-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--add', $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--add', $inherited_ace_str,
++				 $f2-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	smb_cacls('--propagate-inheritance', '--delete', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--delete',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' doesn't have CI|NP/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -1808,6 +1963,7 @@ sub test_simple_oinp_delete
+ 	my $child_file_ace;
+ 	my $child_dir_ace;
+ 	my $ret;
++	my $out;
+ 
+ 	my $f1 = File-&gt;new_local("$TMP/file-1");
+ 	$f1-&gt;put_remote("oi_dir/file-1");
+@@ -1815,13 +1971,21 @@ sub test_simple_oinp_delete
+ 	$f2-&gt;put_remote("oi_dir/nested/file-2");
+ 
+ 	# set up 'before' permissions
+-	smb_cacls('--add', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
+-	smb_cacls('--add', $inherited_ace_str,
+-		  $f1-&gt;smb_remotepath);
++	($out, $ret) = smb_cacls('--add', $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
++	($out, $ret) = smb_cacls('--add', $inherited_ace_str,
++				 $f1-&gt;smb_remotepath);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+-	smb_cacls('--propagate-inheritance', '--delete', $dir_add_acl_str,
+-		  $f1-&gt;smb_remotedir);
++	($out, $ret) = smb_cacls('--propagate-inheritance', '--delete',
++				 $dir_add_acl_str, $f1-&gt;smb_remotedir);
++	if ($ret != 0) {
++		return 1;
++	}
+ 
+ 	# check top level container 'oi_dir' does NOT have OI|NP/READ
+ 	$dir_ace = ace_parse_str($dir_add_acl_str);
+@@ -2295,6 +2459,8 @@ sub ace_parse_str
+ 	#check for domain component in username
+ 	if (index($splat[1], "\\") &gt;= 0) {
+ 		($ace{user_dom}, $ace{user}) = split(/\\/, $splat[1]);
++	} elsif (index($splat[1], "/") &gt;= 0) {
++		($ace{user_dom}, $ace{user}) = split(m%/%, $splat[1]);
+ 	} else {
+ 		$ace{user} = $splat[1];
+ 	}
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/suse/0002-add-new-propagate-inheritance-option-for-smbcacls.patch samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0002-add-new-propagate-inheritance-option-for-smbcacls.patch
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0002-add-new-propagate-inheritance-option-for-smbcacls.patch
@@ -0,0 +1,831 @@
+From 04cbd0c9758aa1bd29b908ba39fda183aa6d5ed6 Mon Sep 17 00:00:00 2001
+From: Noel Power &lt;noel.power@suse.com&gt;
+Date: Thu, 14 Nov 2013 17:45:07 +0000
+Subject: [PATCH] add new '--propagate-inheritance' option for smbcacls
+
+smbcacls now can take a '--propagate-inheritance' flag to indicate that the
+add, delete, modify and set operations now support automatic propagation of
+inheritable ACE(s)
+
+Signed-off-by: Noel Power &lt;noel.power@suse.com&gt;
+---
+ source3/utils/smbcacls.c | 684 +++++++++++++++++++++++++++++++++++++++++++++--
+ 1 file changed, 667 insertions(+), 17 deletions(-)
+
+diff --git source3/utils/smbcacls.c source3/utils/smbcacls.c
+index 7c18d1c..06b535f 100644
+--- source3/utils/smbcacls.c
++++ source3/utils/smbcacls.c
+@@ -6,6 +6,7 @@
+    Copyright (C) Tim Potter      2000
+    Copyright (C) Jeremy Allison  2000
+    Copyright (C) Jelmer Vernooij 2003
++   Copyright (C) Noel Power &lt;noel.power@suse.com&gt; 2013
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+@@ -33,10 +34,13 @@
+ #include "../librpc/gen_ndr/ndr_lsa_c.h"
+ #include "util_sd.h"
+ 
++static char DIRSEP_CHAR = '\\';
++
+ static int test_args;
+ 
+ #define CREATE_ACCESS_READ READ_CONTROL_ACCESS
+ 
++static int inheritance = 0;
+ static int sddl;
+ static int query_sec_info = -1;
+ static int set_sec_info = -1;
+@@ -47,6 +51,17 @@ enum acl_mode {SMB_ACL_SET, SMB_ACL_DELETE, SMB_ACL_MODIFY, SMB_ACL_ADD };
+ enum chown_mode {REQUEST_NONE, REQUEST_CHOWN, REQUEST_CHGRP, REQUEST_INHERIT};
+ enum exit_values {EXIT_OK, EXIT_FAILED, EXIT_PARSE_ERROR};
+ 
++struct cacl_callback_state {
++	struct user_auth_info *auth_info;
++	struct cli_state *cli;
++	struct security_descriptor *aclsd;
++	struct security_acl *acl_to_add;
++	enum acl_mode mode;
++	char *the_acl;
++	bool acl_no_propagate;
++	bool numeric;
++};
++
+ static NTSTATUS cli_lsa_lookup_domain_sid(struct cli_state *cli,
+ 					  struct dom_sid *sid)
+ {
+@@ -123,12 +138,14 @@ static struct dom_sid *get_domain_sid(struct cli_state *cli)
+ }
+ 
+ /* add an ACE to a list of ACEs in a struct security_acl */
+-static bool add_ace(struct security_acl **the_acl, struct security_ace *ace)
++static bool add_ace_with_ctx(TALLOC_CTX *ctx, struct security_acl **the_acl,
++			     struct security_ace *ace)
++
+ {
+ 	struct security_acl *new_ace;
+ 	struct security_ace *aces;
+ 	if (! *the_acl) {
+-		return (((*the_acl) = make_sec_acl(talloc_tos(), 3, 1, ace))
++		return (((*the_acl) = make_sec_acl(ctx, 3, 1, ace))
+ 			!= NULL);
+ 	}
+ 
+@@ -138,12 +155,18 @@ static bool add_ace(struct security_acl **the_acl, struct security_ace *ace)
+ 	memcpy(aces, (*the_acl)-&gt;aces, (*the_acl)-&gt;num_aces * sizeof(struct
+ 	security_ace));
+ 	memcpy(aces+(*the_acl)-&gt;num_aces, ace, sizeof(struct security_ace));
+-	new_ace = make_sec_acl(talloc_tos(),(*the_acl)-&gt;revision,1+(*the_acl)-&gt;num_aces, aces);
++	new_ace = make_sec_acl(ctx, (*the_acl)-&gt;revision,
++			       1+(*the_acl)-&gt;num_aces, aces);
+ 	SAFE_FREE(aces);
+ 	(*the_acl) = new_ace;
+ 	return True;
+ }
+ 
++static bool add_ace(struct security_acl **the_acl, struct security_ace *ace)
++{
++	return add_ace_with_ctx(talloc_tos(), the_acl, ace);
++}
++
+ /* parse a ascii version of a security descriptor */
+ static struct security_descriptor *sec_desc_parse(TALLOC_CTX *ctx, struct cli_state *cli, char *str)
+ {
+@@ -250,7 +273,9 @@ static uint16 get_fileinfo(struct cli_state *cli, const char *filename)
+ /*****************************************************
+ get sec desc for filename
+ *******************************************************/
+-static struct security_descriptor *get_secdesc(struct cli_state *cli, const char *filename)
++static struct security_descriptor *get_secdesc_with_ctx(TALLOC_CTX *ctx,
++							struct cli_state *cli,
++							const char *filename)
+ {
+ 	uint16_t fnum = (uint16_t)-1;
+ 	struct security_descriptor *sd;
+@@ -284,7 +309,7 @@ static struct security_descriptor *get_secdesc(struct cli_state *cli, const char
+ 	}
+ 
+ 	status = cli_query_security_descriptor(cli, fnum, sec_info,
+-					       talloc_tos(), &amp;sd);
++					       ctx, &amp;sd);
+ 
+ 	cli_close(cli, fnum);
+ 
+@@ -296,6 +321,11 @@ static struct security_descriptor *get_secdesc(struct cli_state *cli, const char
+         return sd;
+ }
+ 
++static struct security_descriptor *get_secdesc(struct cli_state *cli,
++					       const char *filename)
++{
++	return get_secdesc_with_ctx(talloc_tos(), cli, filename);
++}
+ /*****************************************************
+ set sec desc for filename
+ *******************************************************/
+@@ -485,23 +515,18 @@ static void sort_acl(struct security_acl *the_acl)
+ }
+ 
+ /***************************************************** 
+-set the ACLs on a file given an ascii description
++set the ACLs on a file given a security descriptor
+ *******************************************************/
+ 
+-static int cacl_set(struct cli_state *cli, const char *filename,
+-		    char *the_acl, enum acl_mode mode, bool numeric)
++static int cacl_set_from_sd(struct cli_state *cli, const char *filename,
++			    struct security_descriptor *sd, enum acl_mode mode,
++			    bool numeric)
+ {
+-	struct security_descriptor *sd, *old;
++	struct security_descriptor *old;
+ 	uint32 i, j;
+ 	size_t sd_size;
+ 	int result = EXIT_OK;
+ 
+-	if (sddl) {
+-		sd = sddl_decode(talloc_tos(), the_acl, get_domain_sid(cli));
+-	} else {
+-		sd = sec_desc_parse(talloc_tos(), cli, the_acl);
+-	}
+-
+ 	if (!sd) return EXIT_PARSE_ERROR;
+ 	if (test_args) return EXIT_OK;
+ 
+@@ -606,6 +631,26 @@ static int cacl_set(struct cli_state *cli, const char *filename,
+ }
+ 
+ /*****************************************************
++set the ACLs on a file given an ascii description
++*******************************************************/
++
++static int cacl_set(struct cli_state *cli, const char *filename,
++		    char *the_acl, enum acl_mode mode, bool numeric)
++{
++	struct security_descriptor *sd;
++
++	if (sddl) {
++		sd = sddl_decode(talloc_tos(), the_acl, get_global_sam_sid());
++	} else {
++		sd = sec_desc_parse(talloc_tos(), cli, the_acl);
++	}
++
++	if (!sd) return EXIT_PARSE_ERROR;
++	if (test_args) return EXIT_OK;
++	return cacl_set_from_sd(cli, filename, sd, mode, numeric);
++}
++
++/*****************************************************
+ set the inherit on a file
+ *******************************************************/
+ static int inherit(struct cli_state *cli, const char *filename,
+@@ -774,6 +819,593 @@ static struct cli_state *connect_one(struct user_auth_info *auth_info,
+ 	return c;
+ }
+ 
++/*
++ * Process mntpoint and ensure resulting combination of mntpoint, mask &amp; fname
++ * is terminated with wildcard
++ */
++static char *build_dirname(TALLOC_CTX *ctx, const char *mntpoint,
++	const char *mask, char *dir, char *fname)
++{
++	char *mask2 = NULL;
++	char *p = NULL;
++
++	mask2 = talloc_asprintf(ctx,
++			"%s%s",
++			mntpoint,
++			mask);
++	if (!mask2) {
++		return NULL;
++	}
++	p = strrchr_m(mask2, DIRSEP_CHAR);
++	if (p) {
++		p[1] = 0;
++	} else {
++		mask2[0] = '\0';
++	}
++	mask2 = talloc_asprintf_append(mask2,
++				"%s\\*",
++				fname);
++	return mask2;
++}
++
++/*
++ * Returns the a copy of the ACL flags in ace modified according
++ * to some inheritance rules.
++ *   a) SEC_ACE_FLAG_INHERITED_ACE is propagated to children
++ *   b) SEC_ACE_FLAG_INHERIT_ONLY is set on container children for OI (only)
++ *   c) SEC_ACE_FLAG_OBJECT_INHERIT &amp; SEC_ACE_FLAG_CONTAINER_INHERIT are
++ *      stripped from flags to be propagated to non-container children
++ *   d) SEC_ACE_FLAG_OBJECT_INHERIT &amp; SEC_ACE_FLAG_CONTAINER_INHERIT are
++ *      stripped from flags to be propagated if the NP flag
++ *      SEC_ACE_FLAG_NO_PROPAGATE_INHERIT is present
++ */
++
++static uint8_t get_flags_to_propagate(bool is_container,
++				struct security_ace *ace)
++{
++	uint8_t newflags = ace-&gt;flags;
++	/* OBJECT inheritance */
++	bool acl_objinherit = (ace-&gt;flags &amp;
++		SEC_ACE_FLAG_OBJECT_INHERIT) == SEC_ACE_FLAG_OBJECT_INHERIT;
++	/* CONTAINER inheritance */
++	bool acl_cntrinherit = (ace-&gt;flags &amp;
++		SEC_ACE_FLAG_CONTAINER_INHERIT) ==
++			SEC_ACE_FLAG_CONTAINER_INHERIT;
++	/* PROHIBIT inheritance */
++	bool prohibit_inheritance = ((ace-&gt;flags &amp;
++		SEC_ACE_FLAG_NO_PROPAGATE_INHERIT) ==
++			SEC_ACE_FLAG_NO_PROPAGATE_INHERIT);
++
++	/* all children need to have the SEC_ACE_FLAG_INHERITED_ACE set */
++	if (acl_cntrinherit || acl_objinherit) {
++		newflags |= SEC_ACE_FLAG_INHERITED_ACE;
++		/*
++		 * object inherit ( alone ) on a container needs
++		 * SEC_ACE_FLAG_INHERIT_ONLY
++		 */
++		if (is_container &amp;&amp; acl_objinherit &amp;&amp;
++			!acl_cntrinherit) {
++			newflags |= SEC_ACE_FLAG_INHERIT_ONLY;
++		}
++		if (!is_container || prohibit_inheritance) {
++			/*
++			 * don't apply object/container inheritance flags to
++			 * non dirs or if instructed not to propagate
++			 */
++			newflags &amp;= ~(SEC_ACE_FLAG_OBJECT_INHERIT
++					| SEC_ACE_FLAG_CONTAINER_INHERIT
++					| SEC_ACE_FLAG_INHERIT_ONLY);
++			/*
++			 * don't propagate INHERIT_ONLY (from parent) either */
++			if (!is_container) {
++				newflags &amp;= ~SEC_ACE_FLAG_INHERIT_ONLY;
++			}
++			if (prohibit_inheritance) {
++				newflags &amp;= ~SEC_ACE_FLAG_NO_PROPAGATE_INHERIT;
++			}
++		}
++	} else {
++		newflags &amp;= ~SEC_ACE_FLAG_INHERITED_ACE;
++	}
++	return newflags;
++}
++
++/*
++ * This function builds a new acl for 'caclfile', first it removes any
++ * existing inheritable ace(s) from the current acl of caclfile, secondly it
++ * applies any inheritable acls of the parent of caclfile ( inheritable acls of
++ * caclfile's parent are passed via acl_to_add member of cbstate )
++ *
++ */
++static NTSTATUS propagate_inherited_aces(char *caclfile,
++			struct cacl_callback_state *cbstate)
++{
++	TALLOC_CTX *aclctx = talloc_new(NULL);
++	NTSTATUS status = NT_STATUS_OK;
++	int result;
++	int fileattr = 0;
++	struct security_descriptor *old;
++	bool is_container = false;
++	struct security_acl *acl_to_add = cbstate-&gt;acl_to_add;
++	struct security_acl *acl_to_remove = NULL;
++	uint32_t i, j;
++
++	old = get_secdesc_with_ctx(aclctx, cbstate-&gt;cli, caclfile);
++
++	if (!old) {
++		status = NT_STATUS_UNSUCCESSFUL;
++		goto out;
++	}
++
++	/* inhibit propagation? */
++	if ((old-&gt;type &amp; SEC_DESC_DACL_PROTECTED) ==
++		SEC_DESC_DACL_PROTECTED){
++		status = NT_STATUS_OK;
++		goto out;
++	}
++
++	fileattr = get_fileinfo(cbstate-&gt;cli, caclfile);
++	is_container = (fileattr &amp; FILE_ATTRIBUTE_DIRECTORY);
++
++	/* find acl(s) that are inherited */
++	for (j = 0; old-&gt;dacl &amp;&amp; j &lt; old-&gt;dacl-&gt;num_aces; j++) {
++
++		if (old-&gt;dacl-&gt;aces[j].flags &amp; SEC_ACE_FLAG_INHERITED_ACE) {
++			if (!add_ace_with_ctx(aclctx, &amp;acl_to_remove,
++					      &amp;old-&gt;dacl-&gt;aces[j])) {
++				status = NT_STATUS_NO_MEMORY;
++				goto out;
++			}
++		}
++	}
++
++	/* remove any acl(s) that are inherited */
++	if (acl_to_remove) {
++		for (i = 0; i &lt; acl_to_remove-&gt;num_aces; i++) {
++			struct security_ace ace = acl_to_remove-&gt;aces[i];
++			for (j = 0; old-&gt;dacl &amp;&amp; j &lt; old-&gt;dacl-&gt;num_aces; j++) {
++
++				if (security_ace_equal(&amp;ace,
++						  &amp;old-&gt;dacl-&gt;aces[j])) {
++					uint32_t k;
++					for (k = j; k &lt; old-&gt;dacl-&gt;num_aces-1;
++						k++) {
++						old-&gt;dacl-&gt;aces[k] =
++							old-&gt;dacl-&gt;aces[k+1];
++					}
++					old-&gt;dacl-&gt;num_aces--;
++					break;
++				}
++			}
++		}
++	}
++	/* propagate any inheritable ace to be added */
++	if (acl_to_add) {
++		for (i = 0; i &lt; acl_to_add-&gt;num_aces; i++) {
++			struct security_ace ace = acl_to_add-&gt;aces[i];
++			bool is_objectinherit = (ace.flags &amp;
++				SEC_ACE_FLAG_OBJECT_INHERIT) ==
++					SEC_ACE_FLAG_OBJECT_INHERIT;
++			/* don't propagate flags to a file unless OI */
++			if (!is_objectinherit &amp;&amp; !is_container) {
++				continue;
++			}
++			/*
++			 * adjust flags according to inheritance
++			 * rules
++			 */
++			ace.flags = get_flags_to_propagate(is_container, &amp;ace);
++			bool is_inherited = (ace.flags &amp;
++				SEC_ACE_FLAG_INHERITED_ACE) ==
++					SEC_ACE_FLAG_INHERITED_ACE;
++			/* don't propagate non inherited flags */
++			if (!is_inherited) {
++				continue;
++			}
++			if (!add_ace_with_ctx(aclctx, &amp;old-&gt;dacl, &amp;ace)) {
++				status = NT_STATUS_NO_MEMORY;
++				goto out;
++			}
++		}
++	}
++
++	result = cacl_set_from_sd(cbstate-&gt;cli, caclfile,
++				  old,
++				  SMB_ACL_SET, cbstate-&gt;numeric);
++	if (result  != EXIT_OK) {
++		status = NT_STATUS_UNSUCCESSFUL;
++		goto out;
++	}
++
++	TALLOC_FREE(aclctx);
++out:
++	return status;
++}
++
++/*
++ * Returns true if 'ace' contains SEC_ACE_FLAG_OBJECT_INHERIT or
++ * SEC_ACE_FLAG_CONTAINER_INHERIT
++ */
++static bool is_inheritable_ace(struct security_ace *ace)
++{
++	uint8_t flags = ace-&gt;flags;
++	if (flags &amp; (SEC_ACE_FLAG_OBJECT_INHERIT
++			| SEC_ACE_FLAG_CONTAINER_INHERIT)) {
++		return true;
++	}
++	return false;
++}
++
++/* This method does some basic sanity checking with respect to automatic
++ * inheritance. e.g. it checks if it is possible to do a set, it detects illegal
++ * attempts to set inherited permissions directly. Additionally this method
++ * does some basic initialisation for instance it parses the ACL passed on the
++ * command line.
++ */
++static NTSTATUS prepare_inheritance_propagation(TALLOC_CTX *ctx, char *filename,
++			struct cacl_callback_state *cbstate)
++{
++	NTSTATUS result = NT_STATUS_OK;
++	char *the_acl = cbstate-&gt;the_acl;
++	struct cli_state *cli = cbstate-&gt;cli;
++	enum acl_mode mode = cbstate-&gt;mode;
++	struct security_descriptor *sd = NULL;
++	struct security_descriptor *old = get_secdesc_with_ctx(ctx, cli,
++							       filename);
++	uint32_t j;
++	bool propagate = false;
++	/* parse acl passed on the command line */
++	if (sddl) {
++		cbstate-&gt;aclsd = sddl_decode(ctx, the_acl,
++					     get_global_sam_sid());
++	} else {
++		cbstate-&gt;aclsd = sec_desc_parse(ctx, cli, the_acl);
++	}
++
++	if (!cbstate-&gt;aclsd) {
++		result = NT_STATUS_UNSUCCESSFUL;
++		goto out;
++	}
++
++	sd = cbstate-&gt;aclsd;
++
++	/* set operation if inheritance is enabled doesn't make sense */
++	if (mode == SMB_ACL_SET &amp;&amp; ((old-&gt;type &amp; SEC_DESC_DACL_PROTECTED) !=
++		SEC_DESC_DACL_PROTECTED)){
++		d_printf("Inheritance enabled at %s, can't apply set operation\n",filename);
++		result = NT_STATUS_UNSUCCESSFUL;
++		goto out;
++
++	}
++
++	/*
++	 * search command line acl for any illegal SEC_ACE_FLAG_INHERITED_ACE
++	 * flags that are set
++	 */
++	for (j = 0; sd-&gt;dacl &amp;&amp; j &lt; sd-&gt;dacl-&gt;num_aces; j++) {
++		struct security_ace *ace = &amp;sd-&gt;dacl-&gt;aces[j];
++		if (ace-&gt;flags &amp; SEC_ACE_FLAG_INHERITED_ACE) {
++			d_printf("Illegal paramater %s\n", the_acl);
++			result = NT_STATUS_UNSUCCESSFUL;
++			goto out;
++		}
++		if (!propagate) {
++			if (is_inheritable_ace(ace)) {
++				propagate = true;
++			}
++		}
++	}
++out:
++	cbstate-&gt;acl_no_propagate = !propagate;
++	return result;
++}
++
++/*
++ * This method builds inheritable ace(s) from filename (which should be
++ * a container) that need propagating to children in order to provide
++ * automatic inheritance. Those inheritably ace(s) are stored in
++ * acl_to_add member of cbstate for later processing
++ * (see propagate_inherited_aces)
++ */
++static NTSTATUS get_parents_inheritable_aces(TALLOC_CTX *ctx, char *filename,
++			struct cacl_callback_state *cbstate)
++{
++	NTSTATUS result = NT_STATUS_OK;
++	struct cli_state *cli = cbstate-&gt;cli;
++	struct security_descriptor *sd = get_secdesc_with_ctx(ctx, cli,
++							       filename);
++	struct security_acl *acl_to_add = NULL;
++	int j;
++	/*
++	 * Check if any inheritance related flags are used, if not then
++	 * nothing to do. At the same time populate acls for inheritance
++	 * related ace(s) that need to be added to or deleted from children as
++	 * a result of inheritance propagation.
++	 */
++
++	for (j = 0; sd-&gt;dacl &amp;&amp; j &lt; sd-&gt;dacl-&gt;num_aces; j++) {
++		struct security_ace *ace = &amp;sd-&gt;dacl-&gt;aces[j];
++		if (is_inheritable_ace(ace)) {
++			bool added = add_ace_with_ctx(ctx, &amp;acl_to_add, ace);
++			if (!added) {
++				result = NT_STATUS_NO_MEMORY;
++				goto out;
++			}
++		}
++	}
++	cbstate-&gt;acl_to_add = acl_to_add;
++out:
++	return result;
++}
++
++/*
++ * Callback handler to handle child elements processed by cli_list,  we attempt
++ * to propagate inheritable ace(s) to each child via the function
++ * propagate_inherited_aces. Children that are themselves directories are passed
++ * to cli_list again ( to decend the directory structure )
++ */
++static NTSTATUS cacl_set_cb(const char *mntpoint, struct file_info *f,
++			   const char *mask, void *state)
++{
++	struct cacl_callback_state *cbstate =
++		(struct cacl_callback_state *)state;
++	struct cli_state *cli = cbstate-&gt;cli;
++	struct user_auth_info *auth_info = cbstate-&gt;auth_info;
++
++	TALLOC_CTX *dirctx = talloc_new(NULL);
++	NTSTATUS status = NT_STATUS_OK;
++
++	char *dir = NULL;
++	char *dir_end = NULL;
++	char *mask2 = NULL;
++	char *targetpath = NULL;
++	char *caclfile = NULL;
++
++	/* Work out the directory. */
++	dir = talloc_strdup(dirctx, mask);
++	if (!dir) {
++		status = NT_STATUS_NO_MEMORY;
++		goto out;
++	}
++
++	dir_end = strrchr(dir, DIRSEP_CHAR);
++	if (dir_end != NULL) {
++		*dir_end = '\0';
++	}
++
++	if (f-&gt;mode &amp; FILE_ATTRIBUTE_DIRECTORY) {
++		struct cli_state *targetcli = NULL;
++		struct cacl_callback_state dir_cbstate;
++		uint16_t attribute = FILE_ATTRIBUTE_DIRECTORY
++			| FILE_ATTRIBUTE_SYSTEM
++			| FILE_ATTRIBUTE_HIDDEN;
++		dir_end = NULL;
++
++		if (!f-&gt;name || !f-&gt;name[0]) {
++			d_printf("Empty dir name returned. Possible server misconfiguration.\n");
++			status = NT_STATUS_UNSUCCESSFUL;
++			goto out;
++		}
++
++		/* ignore special '.' &amp; '..' */
++		if (!f-&gt;name || strequal(f-&gt;name, ".") ||
++			strequal(f-&gt;name, "..")) {
++			status = NT_STATUS_OK;
++			goto out;
++		}
++
++		mask2 = build_dirname(dirctx, mntpoint, mask, dir, f-&gt;name);
++		if (mask2 == NULL) {
++			status = NT_STATUS_NO_MEMORY;
++			goto out;
++		}
++
++		/* check for dfs */
++		status = cli_resolve_path(dirctx, "", auth_info, cli,
++			mask2, &amp;targetcli, &amp;targetpath);
++		if (!NT_STATUS_IS_OK(status)) {
++			goto out;
++		}
++
++		/*
++		 * prepare path to caclfile, remove any existing wildcard
++		 * chars and convert path separators.
++		 */
++
++		caclfile = talloc_strdup(dirctx, targetpath);
++		if (!caclfile) {
++			status = NT_STATUS_NO_MEMORY;
++			goto out;
++		}
++		dir_end = strrchr(caclfile, '*');
++		if (dir_end != NULL) {
++			*dir_end = '\0';
++		}
++
++		string_replace(caclfile, '/', '\\');
++
++		/* attempt to propagate any inherited ace to child */
++		status = propagate_inherited_aces(caclfile, cbstate);
++		if (!NT_STATUS_IS_OK(status)) {
++			goto out;
++		}
++
++		/* get acls from parent (e.g. caclfile) */
++		dir_cbstate = *cbstate;
++		status = get_parents_inheritable_aces(dirctx, caclfile,
++						      &amp;dir_cbstate);
++		if (!NT_STATUS_IS_OK(status)) {
++			goto out;
++		}
++
++		/*
++		 * ensure cacl_set_cb gets called for children
++		 * of the directory (targetpath)
++		 */
++		status = cli_list(targetcli, targetpath,
++			attribute, cacl_set_cb,
++			(void *)&amp;dir_cbstate);
++
++		if (!NT_STATUS_IS_OK(status)) {
++			goto out;
++		}
++
++	} else {
++		/*
++		 * build full path to caclfile and replace '/' with '\' so
++		 * other utility functions can deal with it
++		 */
++
++		caclfile = talloc_asprintf(dirctx, "%s/%s", dir, f-&gt;name);
++		if (!caclfile) {
++			status = NT_STATUS_NO_MEMORY;
++			goto out;
++		}
++
++		string_replace(caclfile, '/', '\\');
++
++		/* attempt to propagate any inherited ace to file caclfile */
++		status = propagate_inherited_aces(caclfile, cbstate);
++
++		if (!NT_STATUS_IS_OK(status)) {
++			goto out;
++		}
++	}
++	status = NT_STATUS_OK;
++out:
++	if (!NT_STATUS_IS_OK(status)) {
++		d_printf("error %s: processing %s\n",
++			nt_errstr(status),
++			caclfile);
++	}
++	TALLOC_FREE(dirctx);
++	return status;
++}
++
++
++/*
++ * Wrapper around cl_list to decend the directory tree pointed to by 'filename',
++ * helper callback function 'cacl_set_cb' handles the child elements processed
++ * by cli_list.
++ */
++static int inheritance_cacl_set(char *filename,
++			struct cacl_callback_state *cbstate)
++{
++	int result = EXIT_OK;
++	NTSTATUS ntstatus;
++	int fileattr = 0;
++	char *targetpath = NULL;
++	char *mask = NULL;
++	struct cli_state *cli = cbstate-&gt;cli;
++	struct cli_state *targetcli = NULL;
++	struct user_auth_info *auth_info = cbstate-&gt;auth_info;
++	TALLOC_CTX *ctx = talloc_new(NULL);
++	bool isdirectory = false;
++	uint16_t attribute = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM
++				| FILE_ATTRIBUTE_HIDDEN;
++	/* ensure we have a filename that starts with '\' */
++	if (!filename || *filename != DIRSEP_CHAR) {
++		/* illegal or no filename */
++		result = EXIT_FAILED;
++		d_printf("illegal or missing name '%s'\n", filename);
++		goto out;
++	}
++
++	fileattr = get_fileinfo(cli, filename);
++	isdirectory = (fileattr &amp; FILE_ATTRIBUTE_DIRECTORY)
++		== FILE_ATTRIBUTE_DIRECTORY;
++
++	/*
++	 * if we've got as far as here then we have already evaluated
++	 * the args.
++	 */
++	if (test_args) {
++		goto out;
++	}
++
++	mask = NULL;
++	/* make sure we have a trailing '\*' for directory */
++	if (!isdirectory) {
++		mask = talloc_strdup(ctx, filename);
++	} else if (strlen(filename) &gt; 1) {
++		/*
++		 * if the passed file name doesn't have a trailing '\'
++		 * append it.
++		 */
++		char *name_end = strrchr(filename, DIRSEP_CHAR);
++		if (name_end != filename + strlen(filename) + 1) {
++			mask = talloc_asprintf(ctx, "%s\\*", filename);
++		} else {
++			mask = talloc_strdup(ctx, filename);
++		}
++	} else {
++		/* filename is a single '\', just append '*' */
++		mask = talloc_asprintf_append(mask, "%s*", filename);
++	}
++
++	if (!mask) {
++		result = EXIT_FAILED;
++		goto out;
++	}
++
++	/* check for dfs */
++	ntstatus = cli_resolve_path(ctx, "", auth_info, cli, mask, &amp;targetcli,
++		&amp;targetpath);
++	if (NT_STATUS_IS_OK(ntstatus)) {
++		/*
++		 * prepare for automatic propagation of the acl passed on the
++		 * cmdline.
++		 */
++		ntstatus = prepare_inheritance_propagation(ctx, filename,
++							   cbstate);
++	}
++
++	if (!NT_STATUS_IS_OK(ntstatus)) {
++		d_printf("error: %s processing %s\n",
++			 nt_errstr(ntstatus), targetpath);
++		result = EXIT_FAILED;
++		goto out;
++	}
++	result = cacl_set_from_sd(cli, filename, cbstate-&gt;aclsd,
++				cbstate-&gt;mode, cbstate-&gt;numeric);
++
++	/*
++	 * strictly speaking it could be considered an error if a file was
++	 * specificied with '--propagate-inheritance'. However we really want
++	 * to eventually get rid of '--propagate-inheritance' so we will be
++	 * more forgiving here and instead just exit early.
++	 */
++	if (!isdirectory || (result != EXIT_OK)) {
++		goto out;
++	}
++
++	if (NT_STATUS_IS_OK(ntstatus)) {
++		/* check if there is actually any need to propagate */
++		if (cbstate-&gt;acl_no_propagate) {
++			goto out;
++		}
++		/* get inheritable attributes from parent (e.g. filepath) */
++		ntstatus = get_parents_inheritable_aces(ctx, filename,
++							cbstate);
++		if (NT_STATUS_IS_OK(ntstatus)) {
++			/* process children */
++			ntstatus = cli_list(targetcli, targetpath, attribute,
++				cacl_set_cb,
++				(void *)cbstate);
++		}
++	}
++
++	if (!NT_STATUS_IS_OK(ntstatus)) {
++		d_printf("error: %s processing %s\n",
++			 nt_errstr(ntstatus), targetpath);
++		result = EXIT_FAILED;
++		goto out;
++	}
++out:
++	TALLOC_FREE(ctx);
++	return result;
++}
++
+ /****************************************************************************
+   main program
+ ****************************************************************************/
+@@ -803,6 +1435,7 @@ int main(int argc, char *argv[])
+ 		{ "chgrp", 'G', POPT_ARG_STRING, NULL, 'G', "Change group ownership of a file", "GROUPNAME" },
+ 		{ "inherit", 'I', POPT_ARG_STRING, NULL, 'I', "Inherit allow|remove|copy" },
+ 		{ "numeric", 0, POPT_ARG_NONE, &amp;numeric, 1, "Don't resolve sids or masks to names" },
++		{ "propagate-inheritance", 0, POPT_ARG_NONE, &amp;inheritance, 1, "Supports propagation of inheritable ACE(s) when used in conjunction with add, delete, set or modify" },
+ 		{ "sddl", 0, POPT_ARG_NONE, &amp;sddl, 1, "Output and input acls in sddl format" },
+ 		{ "query-security-info", 0, POPT_ARG_INT, &amp;query_sec_info, 1,
+ 		  "The security-info flags for queries"
+@@ -886,8 +1519,11 @@ int main(int argc, char *argv[])
+ 			break;
+ 		}
+ 	}
++	if (inheritance &amp;&amp; !the_acl) {
++		poptPrintUsage(pc, stderr, 0);
++		return -1;
++	}
+ 
+-	/* Make connection to server */
+ 	if(!poptPeekArg(pc)) {
+ 		poptPrintUsage(pc, stderr, 0);
+ 		return -1;
+@@ -929,6 +1565,7 @@ int main(int argc, char *argv[])
+ 	*share = 0;
+ 	share++;
+ 
++	/* Make connection to server */
+ 	if (!test_args) {
+ 		cli = connect_one(auth_info, server, share);
+ 		if (!cli) {
+@@ -955,7 +1592,20 @@ int main(int argc, char *argv[])
+ 	} else if (change_mode != REQUEST_NONE) {
+ 		result = owner_set(cli, change_mode, filename, owner_username);
+ 	} else if (the_acl) {
+-		result = cacl_set(cli, filename, the_acl, mode, numeric);
++		if (inheritance) {
++			struct cacl_callback_state cbstate;
++			cbstate.auth_info = auth_info;
++			cbstate.cli = cli;
++			cbstate.aclsd = NULL;
++			cbstate.acl_to_add = NULL;
++			cbstate.mode = mode;
++			cbstate.the_acl = the_acl;
++			cbstate.acl_no_propagate = false;
++			cbstate.numeric = numeric;
++			result = inheritance_cacl_set(filename, &amp;cbstate);
++		} else {
++			result = cacl_set(cli, filename, the_acl, mode, numeric);
++		}
+ 	} else {
+ 		result = cacl_dump(cli, filename, numeric);
+ 	}
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/suse/0003-doc-describe-smbcacls-propagate-inheritance.patch samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0003-doc-describe-smbcacls-propagate-inheritance.patch
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0003-doc-describe-smbcacls-propagate-inheritance.patch
@@ -0,0 +1,101 @@
+From c2f6b1453c40f41ff7e98b5acd1beadca439de0b Mon Sep 17 00:00:00 2001
+From: David Disseldorp &lt;ddiss@samba.org&gt;
+Date: Thu, 14 Nov 2013 19:38:19 +0100
+Subject: [PATCH] doc: describe smbcacls --propagate-inheritance
+
+Signed-off-by: David Disseldorp &lt;ddiss@samba.org&gt;
+---
+ docs-xml/manpages/smbcacls.1.xml | 48 ++++++++++++++++++++++++++++++++--------
+ 1 file changed, 39 insertions(+), 9 deletions(-)
+
+diff --git docs-xml/manpages/smbcacls.1.xml docs-xml/manpages/smbcacls.1.xml
+index de57b86..ea3e063 100644
+--- docs-xml/manpages/smbcacls.1.xml
++++ docs-xml/manpages/smbcacls.1.xml
+@@ -28,6 +28,7 @@
+ 		&lt;arg choice="opt"&gt;-C|--chown name&lt;/arg&gt;
+ 		&lt;arg choice="opt"&gt;-G|--chgrp name&lt;/arg&gt;
+ 		&lt;arg choice="opt"&gt;-I allow|remove|copy&lt;/arg&gt;
++		&lt;arg choice="opt"&gt;--propagate-inheritance&lt;/arg&gt;
+ 		&lt;arg choice="opt"&gt;--numeric&lt;/arg&gt;
+ 		&lt;arg choice="opt"&gt;-t&lt;/arg&gt;
+ 		&lt;arg choice="opt"&gt;-U username&lt;/arg&gt;
+@@ -131,11 +132,18 @@
+ 		permissions" check box using the &lt;parameter&gt;-I&lt;/parameter&gt;
+ 		option.  To set the check box pass allow. To unset the check
+ 		box pass either remove or copy. Remove will remove all
+-		inherited acls. Copy will copy all the inherited acls.
++		inherited ACEs. Copy will copy all the inherited ACEs.
+ 		&lt;/para&gt;&lt;/listitem&gt;
+ 
+ 		&lt;/varlistentry&gt;
+ 
++		&lt;varlistentry&gt;
++		&lt;term&gt;--propagate-inheritance&lt;/term&gt;
++		&lt;listitem&gt;&lt;para&gt;Add, modify, delete or set ACEs on an entire
++		directory tree according to the inheritance flags. Refer to the
++		INHERITANCE section for details.
++		&lt;/para&gt;&lt;/listitem&gt;
++		&lt;/varlistentry&gt;
+ 
+ 		&lt;varlistentry&gt;
+ 		&lt;term&gt;--numeric&lt;/term&gt;
+@@ -229,18 +237,22 @@ ACL:&amp;lt;sid or name&amp;gt;:&amp;lt;type&amp;gt;/&amp;lt;flags&amp;gt;/&amp;lt;mask&amp;gt;
+ 	determine the type of access granted to the SID. &lt;/para&gt;
+ 
+ 	&lt;para&gt;The type can be either ALLOWED or	DENIED to allow/deny access 
+-	to the SID. The flags values are generally zero for file ACEs and
+-	either 9 or 2 for directory ACEs.  Some common flags are: &lt;/para&gt;
++	to the SID.&lt;/para&gt;
++
++	&lt;para&gt;The flags field defines how the ACE should be considered when
++	performing inheritance. &lt;command&gt;smbcacls&lt;/command&gt; uses these flags
++	when run with &lt;parameter&gt;--propagate-inheritance&lt;/parameter&gt;.&lt;/para&gt;
++
++	&lt;para&gt;Flags can be specified as decimal or hexadecimal values, or with
++	the respective (XX) aliases, separated by a vertical bar "|".&lt;/para&gt;
+ 
+ 	&lt;itemizedlist&gt; 
+-		&lt;listitem&gt;&lt;para&gt;&lt;constant&gt;#define SEC_ACE_FLAG_OBJECT_INHERIT     	0x1&lt;/constant&gt;&lt;/para&gt;&lt;/listitem&gt;
+-		&lt;listitem&gt;&lt;para&gt;&lt;constant&gt;#define SEC_ACE_FLAG_CONTAINER_INHERIT  	0x2&lt;/constant&gt;&lt;/para&gt;&lt;/listitem&gt;
+-		&lt;listitem&gt;&lt;para&gt;&lt;constant&gt;#define SEC_ACE_FLAG_NO_PROPAGATE_INHERIT     0x4&lt;/constant&gt;&lt;/para&gt;&lt;/listitem&gt;
+-		&lt;listitem&gt;&lt;para&gt;&lt;constant&gt;#define SEC_ACE_FLAG_INHERIT_ONLY       	0x8&lt;/constant&gt;&lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;&lt;emphasis&gt;(OI)&lt;/emphasis&gt; Object Inherit	0x1&lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;&lt;emphasis&gt;(CI)&lt;/emphasis&gt; Container Inherit  	0x2&lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;&lt;emphasis&gt;(NP)&lt;/emphasis&gt; No Propagate Inherit	0x4&lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;&lt;emphasis&gt;(IO)&lt;/emphasis&gt; Inherit Only       	0x8&lt;/para&gt;&lt;/listitem&gt;
+  	&lt;/itemizedlist&gt;
+   
+-	&lt;para&gt;At present, flags can only be specified as decimal or
+-	hexadecimal values.&lt;/para&gt;
+  
+ 	&lt;para&gt;The mask is a value which expresses the access right 
+ 	granted to the SID. It can be given as a decimal or hexadecimal value, 
+@@ -271,6 +283,24 @@ ACL:&amp;lt;sid or name&amp;gt;:&amp;lt;type&amp;gt;/&amp;lt;flags&amp;gt;/&amp;lt;mask&amp;gt;
+ 	&lt;/refsect1&gt;
+ 
+ &lt;refsect1&gt;
++	&lt;title&gt;INHERITANCE&lt;/title&gt;
++
++	&lt;para&gt;Per-ACE inheritance flags can be set in the ACE flags field. By
++	default, ACEs marked for object inheritance (OI) or container
++	inheritance (CI) are not propagated to sub-files or folders. However,
++	with the &lt;parameter&gt;--propagate-inheritance&lt;/parameter&gt; arguement
++	specified, such ACEs are recursively applied to all applicable child
++	objects in the directory tree.&lt;/para&gt;
++
++	&lt;para&gt;Any ACEs applied to sub-files of folders are marked with the
++	inherited (I) flag.&lt;/para&gt;
++
++	&lt;para&gt;Files and folders with protected ACLs do not allow inheritable
++	permissions (set with &lt;parameter&gt;-I&lt;/parameter&gt;). Such objects will
++	not receive ACEs flagged for inheritance with (CI) or (OI).&lt;/para&gt;
++&lt;/refsect1&gt;
++
++&lt;refsect1&gt;
+ 	&lt;title&gt;EXIT STATUS&lt;/title&gt;
+ 
+ 	&lt;para&gt;The &lt;command&gt;smbcacls&lt;/command&gt; program sets the exit status 
+-- 
+2.1.4
+
diff --bs samba.2370/patches.tar.bz2/suse/0004-doc-describe-smbcacls-propagate-inheritance-expandin.patch samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0004-doc-describe-smbcacls-propagate-inheritance-expandin.patch
--- /dev/null
+++ samba.SUSE_SLE-12-SP1_Update/patches.tar.bz2/suse/0004-doc-describe-smbcacls-propagate-inheritance-expandin.patch
@@ -0,0 +1,105 @@
+From 197a89bf83fa808ecb81dd025b37aa26c07e325c Mon Sep 17 00:00:00 2001
+From: Noel Power &lt;noel.power@suse.com&gt;
+Date: Fri, 15 Nov 2013 11:53:35 +0000
+Subject: [PATCH 4/4] doc: describe smbcacls --propagate-inheritance expanding
+ INHERITANCE section
+
+Signed-off-by: Noel Power &lt;noel.power@suse.com&gt;
+---
+ docs-xml/manpages/smbcacls.1.xml | 80 +++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 71 insertions(+), 9 deletions(-)
+
+Index: docs-xml/manpages/smbcacls.1.xml
+===================================================================
+--- docs-xml/manpages/smbcacls.1.xml.orig
++++ docs-xml/manpages/smbcacls.1.xml
+@@ -286,18 +286,80 @@ ACL:&amp;lt;sid or name&amp;gt;:&amp;lt;type&amp;gt;/&amp;lt
+ 	&lt;title&gt;INHERITANCE&lt;/title&gt;
+ 
+ 	&lt;para&gt;Per-ACE inheritance flags can be set in the ACE flags field. By
+-	default, ACEs marked for object inheritance (OI) or container
+-	inheritance (CI) are not propagated to sub-files or folders. However,
+-	with the &lt;parameter&gt;--propagate-inheritance&lt;/parameter&gt; arguement
+-	specified, such ACEs are recursively applied to all applicable child
+-	objects in the directory tree.&lt;/para&gt;
+-
+-	&lt;para&gt;Any ACEs applied to sub-files of folders are marked with the
+-	inherited (I) flag.&lt;/para&gt;
+-
++	default, inheritable ACEs e.g. those marked for object inheritance (OI)
++	or container inheritance (CI), are not propagated to sub-files or
++	folders. However, with the
++	&lt;parameter&gt;--propagate-inheritance&lt;/parameter&gt; argument specified, such
++	ACEs are automatically propagated according to some inheritance
++	rules.
++	&lt;itemizedlist&gt;
++		&lt;listitem&gt;&lt;para&gt;Inheritable (OI)(OI) ACE flags can only be
++		applied to folders. &lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;Any inheritable ACEs applied to sub-files or
++		folders are marked with the inherited (I) flag. Inheritable
++		ACE(s) are applied to folders unless the no propagation (NP)
++		flag is set. &lt;/para&gt;
++		&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;When an ACE with the (OI) flag alone set is
++		progagated to a child folder the inheritance only flag (IO) is
++		also applied. This indicates the permissions associated with
++		the ACE don't apply to the folder itself (only to it's
++		child files). When applying the ACE to a child file the ACE is
++		inherited as normal.&lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;When an ace with the (CI) flag alone set is
++		propagated to a child file there is no effect, when propagated
++		to a child folder it is inherited as normal.
++		&lt;/para&gt;&lt;/listitem&gt;
++		&lt;listitem&gt;&lt;para&gt;When an ACE that has both (OI) &amp;amp; (CI) flags
++		set the ACE is inherited as normal by both folders and
++		files.&lt;/para&gt;&lt;/listitem&gt;
++	&lt;/itemizedlist&gt;&lt;/para&gt;
++&lt;para&gt;(OI)(READ) added to parent folder&lt;/para&gt;
++&lt;para&gt;&lt;programlisting&gt;
+++-parent/        (OI)(READ)
++| +-file.1       (I)(READ)
++| +-nested/      (OI)(IO)(I)(READ)
++  |   +-file.2   (I)(READ)
++&lt;/programlisting&gt;&lt;/para&gt;
++&lt;para&gt;(CI)(READ) added to parent folder&lt;/para&gt;
++&lt;para&gt;&lt;programlisting&gt;
+++-parent/        (CI)(READ)
++| +-file.1
++| +-nested/      (CI)(I)(READ)
++  |   +-file.2
++&lt;/programlisting&gt;&lt;/para&gt;
++&lt;para&gt;(OI)(CI)(READ) added to parent folder&lt;/para&gt;
++&lt;para&gt;&lt;programlisting&gt;
+++-parent/        (OI)(CI)(READ)
++| +-file.1       (I)(READ)
++| +-nested/      (OI)(CI(I)(READ)
++  |   +-file.2   (I)(READ)
++&lt;/programlisting&gt;&lt;/para&gt;
++&lt;para&gt;(OI)(NP)(READ) added to parent folder&lt;/para&gt;
++&lt;para&gt;&lt;programlisting&gt;
+++-oi_dir/        (OI)(NP)(READ)
++| +-file.1       (I)(READ)
++| +-nested/
++|   +-file.2
++&lt;/programlisting&gt;&lt;/para&gt;
++&lt;para&gt;(CI)(NP)(READ) added to parent folder&lt;/para&gt;
++&lt;para&gt;&lt;programlisting&gt;
+++-oi_dir/        (CI)(NP)(READ)
++| +-file.1
++| +-nested/      (I)(READ)
++|   +-file.2
++&lt;/programlisting&gt;&lt;/para&gt;
++&lt;para&gt;(OI)(CI)(NP)(READ) added to parent folder&lt;/para&gt;
++&lt;para&gt;&lt;programlisting&gt;
+++-parent/        (CI)(OI)(NP)(READ)
++| +-file.1       (I)(READ)
++| +-nested/      (I)(READ)
++|   +-file.2
++&lt;/programlisting&gt;&lt;/para&gt;
+ 	&lt;para&gt;Files and folders with protected ACLs do not allow inheritable
+ 	permissions (set with &lt;parameter&gt;-I&lt;/parameter&gt;). Such objects will
+ 	not receive ACEs flagged for inheritance with (CI) or (OI).&lt;/para&gt;
++
+ &lt;/refsect1&gt;
+ 
+ &lt;refsect1&gt;
diff --bs samba.2370/samba.changes samba.SUSE_SLE-12-SP1_Update/samba.changes
--- samba.2370/samba.changes
+++ samba.SUSE_SLE-12-SP1_Update/samba.changes
@@ -1,4 +1,33 @@
 -------------------------------------------------------------------
+Tue May 10 18:33:35 UTC 2016 - nopower@suse.com
+
+- libads: record session expiry for spnego sasl binds; (bso#11852);
+  (bsc#979268).
+
+-------------------------------------------------------------------
+Thu Apr 28 13:36:01 UTC 2016 - nopower@suse.com
+
+- fix NT_STATUS_ACCESS_DENIED when accessing windows public share;
+  (bso#11841).
+- Only validate MIC if "map to guest" is not being used; (bso#11847).
+- NetAPP SMB servers don't negotiate NTLMSSP_SIGN; (bso#11850);
+  (bsc#977669).
+- Fix non-working anonymous smb connections; (bso#11858).
+- handle broken mechListMIC response from Windows 2000; (bso#11870).
+- wbinfo -u or net ads search doesn't work anymore; (bso#11872).
+
+-------------------------------------------------------------------
+Tue Apr 19 12:04:48 UTC 2016 - nopower@suse.com
+
+- fix regressions regarding the NTLMSSP hardening of CVE-2016-2110;
+  (bso#11849).
+
+-------------------------------------------------------------------
+Tue Apr 12 08:53:56 UTC 2016 - nopower@suse.com
+
+- Allow Domain member resolve trusted domains' users; (bso#11830).
+
+-------------------------------------------------------------------
 Fri Apr  8 12:02:43 UTC 2016 - aaptel@suse.com
 
 - A man-in-the-middle can downgrade NTLMSSP authentication;
diff --bs samba.2370/samba.spec samba.SUSE_SLE-12-SP1_Update/samba.spec
--- samba.2370/samba.spec
+++ samba.SUSE_SLE-12-SP1_Update/samba.spec
@@ -145,7 +145,7 @@
 %else
 %define	build_make_smp_mflags %{?jobs:-j%jobs}
 %endif
-%define SOURCE_TIMESTAMP 3638
+%define SOURCE_TIMESTAMP 3668
 %define BRANCH %{version}.SLE12_SP1
 %global with_mitkrb5 1
 %global with_dc 0
diff --bs samba.2370/vendor-files.tar.bz2/tools/package-data samba.SUSE_SLE-12-SP1_Update/vendor-files.tar.bz2/tools/package-data
--- samba.2370/vendor-files.tar.bz2/tools/package-data
+++ samba.SUSE_SLE-12-SP1_Update/vendor-files.tar.bz2/tools/package-data
@@ -1,2 +1,2 @@
 # This is an autogenrated file.
-SAMBA_PACKAGE_SVN_VERSION="3638"
+SAMBA_PACKAGE_SVN_VERSION="3668"
